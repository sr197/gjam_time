---
title: "Generalized Joint Attribute Modeling for Dynamic Data"
author: '[James S. Clark](http://sites.nicholas.duke.edu/clarklab/)'
date: "`r Sys.Date()`"
output:
  rmarkdown::pdf_document:
    toc: true
    toc_depth: 3
vignette: >
  %\VignetteIndexEntry{Generalized joint attribute modeling - gjam}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---
```{r}
install.packages('gjam_2.3.tar.gz',repos=NULL, type='source')
```

location for html file: http://rpubs.com/jimclark/551105

```{r, echo = F, eval = T}

#library(gjam)
library(MASS)

# from source files:
source("/Users/jimclark/GJAM/makeGJAMcurrent/RFunctions/gjamHfunctions.R")
source("/Users/jimclark/GJAM/makeGJAMcurrent/RFunctions/gjamTrimY.r")
source("/Users/jimclark/GJAM/makeGJAMcurrent/RFunctions/gjamPriorTemplate.R")
Rcpp::sourceCpp('/Users/jimclark/GJAM/makeGJAMcurrent/RcppFunctions/cppFns.cpp')
```


Here are some functions to simulate data and graph food webs that are sourced from the gjam github site:

```{r, eval = T}
library(devtools)
d <- "https://github.com/jimclarkatduke/gjam/blob/master/gjamTimeFunctions.R?raw=True"
source_url(d)
```

Alternatively, use them here:

```{r, echo = F, eval = F}
source('gjamTimeFunctions.R')

```



#gjam for community dynamics

This is a state-space version of gjam that estimates parameters for community interactions where there are multiple groups interacting over time.  A group could be a location, such as the BBS data for each route or NEON for each site.  It can be viewed as a generalized Lotka-Volterra model with immigration and emigration, connected to data as discussed for gjam [Clark et al. 2017](https://esajournals.onlinelibrary.wiley.com/doi/full/10.1002/ecm.1241).

#Simulated data for diagnostics

A simulation begins with a specification of the number of species, number of sites (or time series), the mean number of time increments (it will vary stochastically), and the observation effort, which is the effort variable of [gjam](https://esajournals.onlinelibrary.wiley.com/doi/full/10.1002/ecm.1241).

```{r, eval = T}
S     <- 6        # no. species
nsite <- 10       # no. time series
ntime <- 100      # mean no. of time steps in a series
obsEffort <- 1    # full census
```



##First example: an AR model

I start with the simple case of an AR(1) model for $S = 6$ species.
Here I specify a design for simulation, including `termR = TRUE`, which refers to the AR term:

```{r, eval = T}
termB <- FALSE    # include immigration/emigration term XB: movement term
termR <- TRUE     # include DI population growth term VL
termA <- FALSE    # include DD spp interaction term UA
```

Here is a simulation using the function `gjamSimTime`, which is sourced at the beginning of this vignette from github.  I have set `Q = 0` to indicate that there are no predictors in the model--it includes only the growth rate parameters:

```{r, eval = T}
seed <- 999
set.seed( seed )
tmp    <- gjamSimTime(S, Q = 0, nsite, ntime, termB, termR, termA, 
                      obsEffort = obsEffort, PLOT = T)
xdata  <- tmp$xdata
ydata  <- tmp$ydata
edata  <- tmp$edata
groups <- tmp$groups
times  <- tmp$times
trueValues <- tmp$trueValues
formula    <- tmp$formula
```

Most of these objects are familiar to [gjam](http://rpubs.com/jimclark/551105) users.  The `list trueValues` holds the parameter values used to generate the data.

The plot generated by `gjamSimTime` identifies the multiple series from each site by colors.

##Missing values in time series data

The function `gjamFillMissingTimes` provides some options for initializing the missing values for analysis.  It takes as input the three observation objects `xdata`, `ydata`, and `edata` and returns new versions of them with added rows for missing times.

First, it will insert one observation at the beginning of the sequence for each group.  This initial "time zero" is the prior for the observation at time 1.  

Second, `gjamFillMissingTimes` inserts a placeholder for missing sample times. The time steps for each group are sequential integer values held in the column `timeCol`. For variables in `xdata` that change at each time step, these can either be filled by the user (preferable) or left as `NA` to be imputed as missing data.  Of course, if there is too much missingness, the fit will deteriorate.  

Third, `gjamFillMissingTimes` will insert values for `ydata` and `edata` to match those added to `xdata`.  These can be `NA` (`FILLMEANS = FALSE`), in which case they will be imputed with an automatically assigned weak prior (small effort).  Alternatively, they can be filled with the mean value for their group, with the strength of the prior controlled by the user-specified `missingEffort`.  These values can be inspected from the effort matrix `edata` that is returned by `gjamFillMissingTimes`.

Recall, the effort `matrix edata` controls the weight of the observations.  

The argument `groupVars` indentifies those columns in `xdata` that are fixed for the group, so they can be filled in by `gjamFillMissingTimes`.  In other words, `groupVars` do not change over time.  These are count data, so the `typeNames = 'DA'`, i.e., 'discrete abundance`.

##mydata
```{r}
total <- read.csv("total.csv")

```
##regridding to be monthly 

```{r}

total$month <- month(total$date)

df <- total %>% group_by(year, month, stratum) %>% summarise_all(mean, na.rm=FALSE)

#adding back categorical data

Mode <- function(x) {
 ux <- unique(x)
 ux[which.max(tabulate(match(x, ux)))]
}


df_SED <- total %>% group_by(year, month, stratum) %>% summarise(SEDIMENT_mode = Mode(SEDIMENT))

#combining all data 
total_agg <- cbind(df, df_SED)

total_agg <- as.data.frame(total_agg)


```

##adding time in my data 
```{r}

#okay lets create a large data frame with all of the time group combinations 
total_expand <- expand(total_agg, month, year, stratum)

#now fill in the values we have: 
total_expand <- left_join(total_expand, total_agg, by=c("month", "year", "stratum"))

#need to fill in missing long and lat by stratum (with averages)
stratum_x_y <- total_expand %>% group_by(stratum) %>% summarize(latitude2 = mean(lat, na.rm=TRUE), longitude2 = mean (lon, na.rm=TRUE)) 

#coordinates of points
total_expand <- left_join(total_expand, stratum_x_y, by=c("stratum"))
total_expand$LATITUDE <- ifelse(is.na(total_expand$lat), total_expand$latitude2, total_expand$lat)

total_expand$LONGITUDE <- ifelse(is.na(total_expand$lon), total_expand$longitude2, total_expand$lon)


total_expand$myid <- 1:nrow(total_expand)
total_expand$day <- 15
total_expand$date <- paste(total_expand$year, total_expand$month, total_expand$day, sep="-") %>% ymd() %>% as.Date()
total_expand_lat_lon_date <- total_expand %>% dplyr::select(LONGITUDE, LATITUDE, myid, date, day, month, year )
write.csv(total_expand, file="total_expanded_grid.csv")
write.csv(total_expand_lat_lon_date, file="total_expanded_grid_simp.csv")


#now fill in missing xdata 

```

##fill in xdata
note I tried adding xdata based on google earth but a lot of the data points did not make sense (sst was 400) so went into arcmap and did it that way. This is how you would do it with google earth if needed 
In Arcmap: filled in missing sst, salinity with HYCOM from MGET interpolate value at points. filled in missing substrate and depth from TNC. needed to do a spatial join on the polygon in habitat called benthic_habitat_poly then do a regular join to benthic habitat_poly_wgs based on GRIDCODE similar to a left join. Then I extracted bathymetry from the bathymetry raster. 

```{r}
# work with raster data
library(raster)
#remember that the raster package interferes with tidyr so may need to uninstall once I get this stuff done. 
# export GeoTIFFs and other core GIS functions
library(rgdal)

```

```{r}
SST = raster("~/Documents/ClimateOceanPlanning/Datasets/Rasters/stackedImage_SST_84_14.tif")
maxValue(SST)
```




```{r}
grayscale_colors <- gray.colors(100,            # number of different color levels 
                                start = 0.0,    # how black (0) to go
                                end = 1.0,      # how white (1) to go
                                gamma = 2.2,    # correction between how a digital 
                                # camera sees the world and how human eyes see it
                                alpha = NULL)   #Null=colors are not transparent

#read in one band 
SST = raster("~/Documents/ClimateOceanPlanning/Datasets/Rasters/stackedImage_SST_84_14.tif", band=2)

plot(SST,
     col=grayscale_colors, # we already created this palette & can use it again
     axes=FALSE,
     main="SST_band1")

#create raster stack of all bands: 
SST_stack = stack("~/Documents/ClimateOceanPlanning/Datasets/Rasters/stackedImage_SST_84_14.tif")

sal_stack = stack("~/Documents/ClimateOceanPlanning/Datasets/Rasters/stackedImage_HYCOM_salinity_92_18.tif")

sst_hycom_stack = stack("~/Documents/ClimateOceanPlanning/Datasets/Rasters/stackedImage_HYCOM_sst_92_18.tif")


total <- read.csv("total.csv")
total$LONGITUDE <- total$decdeg_beglon
total$LATITUDE <- total$decdeg_beglat

pointCoordinates= total %>% dplyr::select(LATITUDE, LONGITUDE)

coordinates(pointCoordinates)= ~ LONGITUDE+ LATITUDE

#extract values at points
rasValue=extract(SST_stack, pointCoordinates)
combinePointValue <- cbind(pointCoordinates,rasValue)


pointCoordinates= total_expand %>% dplyr::select(LATITUDE, LONGITUDE)
combinePointValue <- cbind(pointCoordinates,rasValue)
sst_AVHRR <- combinePointValue 

rasValue = extract(sal_stack, pointCoordinates)
combinePointValue <- cbind(pointCoordinates,rasValue)
sal_hycom <- combinePointValue 

rasValue=extract(sst_hycom_stack, pointCoordinates)
combinePointValue <- cbind(pointCoordinates,rasValue)
sst_hycom <- combinePointValue 




```

reloading gridded xdata, removing NAs
```{r}
grid_xdata <- read.csv("~/Documents/ClimateOceanPlanning/R/NEFSC_GJAMM_GIT/Time/grid_xdata.csv")

#removing columns 
grid_xdata <- grid_xdata %>% dplyr::select (-GRIDCODE, -GRIDCODE_1, -OBJECTID, -FID_1, -ID, - Join_Count, -TARGET_FID, -JOIN_FID, -Field1)
grid_xdata$depth <- grid_xdata$RASTERVALU
grid_xdata <- grid_xdata %>% dplyr::select (-ID_1, -VALUE, -COUNT, -OID_, -RASTERVALU)
#-9999 is NA 
grid_xdata <- grid_xdata %>% mutate_if(is.numeric, list(~na_if(., -9999)))
grid_xdata$depth <- (grid_xdata$depth)*-1 #large positive numbers are large depths
```





##adding time column
```{r}
grid_xdata <- read.csv("grid_xdata_2.csv")
#need to clean up total_expand to add xdata 
#total_expand <- total_expand[1:656]


total_expand_xy <- left_join(total_expand, grid_xdata, by=c("myid"))
library(chron)
total_expand_xy <- total_expand_xy %>% dplyr::select(-TARGET_FID, -JOIN_FID, -Field1, -ID, -GRIDCODE, -OBJECTID, -VALUE, -COUNT, -OID_, -C_BATH, -C_SBF, -C_LPI, -C_SLOPE, -C_SED, -LONGITUDE.y, -LATITUDE.y, -Join_Count, -date.y, -month.y, -year.y)

time_simp <- total_expand_xy %>% dplyr::select(month.x, year.x, stratum, date.x, myid )

time_test <- total_expand_xy %>% dplyr::select(month.x, year.x, stratum, date.x,)

time_test$value =1
time_test <- time_test %>% distinct()

time_test <- time_test %>% spread(stratum, value=value)
time_test <- time_test %>% arrange(year)
time_test_2 <- time_test[4:74] #just the stratums
time_test_3 <- time_test[1:3] #just the dates 
rep.col<-function(x,n){
   matrix(rep(x,each=n), ncol=n, byrow=TRUE)
} #repeat columns

total_fill <- rep.col(1:306,71) #9 months x 34 years = 306 repeat that 71 times (number of unique stratums)
total_fill <- as.data.frame(total_fill)
colnames(total_fill) <- colnames(time_test_2)

time_test_4 <- cbind(time_test_3, total_fill)

time_test_5 <- time_test_4 %>% gather(key = "stratum",
                   value = "time",
                   "1010":"3660")
time_test_5 <- time_test_5 %>% arrange(year.x, month.x)
time_test_5$myid <- rep(1:nrow(time_test_5))

#bind it all together 
#first need to remove the repeating rows in total_expand_xy 
total_expand_xy_2 <- total_expand_xy %>% distinct(year.x, month.x, stratum, .keep_all = TRUE)
total_expand_xy_2$stratum <- as.character(total_expand_xy_2$stratum)
total_expand_xy_time <- left_join(total_expand_xy_2, time_test_5, by=c("year.x" = "year.x", "month.x" = "month.x", "stratum"="stratum"))

write.csv(total_expand_xy_time, file="total_expand_xy_time.csv")
```

##cleaning gridded data
```{r}

total_expanded_grid <- read.csv("~/Documents/ClimateOceanPlanning/R/NEFSC_GJAMM_GIT/Time/total_expanded_grid.csv")
total_expand_xy_time <- read.csv("~/Documents/ClimateOceanPlanning/R/NEFSC_GJAMM_GIT/Time/total_expand_xy_time.csv")

#need to clean up the columns etc
total_expand_xy_time$depth<- total_expand_xy_time$RASTERVALU



#replace -9999 with NA 
total_expand_xy_time[total_expand_xy_time == -9999] <- NA

#fill in SST and SAL to have insitu data and HYCOM when in situ is missing 

in_situ <- total_expanded_grid %>% dplyr::select(bottemp, botsalin, surftemp, surfsalin, myid)
total_expand_xy_time$myid <- total_expand_xy_time$myid.y
total_expand_xy_time <- left_join(total_expand_xy_time, in_situ, by=c("myid"))

total_expand_xy_time$SST <- ifelse(is.na(total_expand_xy_time$surftemp), total_expand_xy_time$SST, total_expand_xy_time$surftemp)
total_expand_xy_time$BT <- ifelse(is.na(total_expand_xy_time$bottemp), total_expand_xy_time$BT, total_expand_xy_time$bottemp)
total_expand_xy_time$SSAL <- ifelse(is.na(total_expand_xy_time$surfsalin), total_expand_xy_time$SSAL, total_expand_xy_time$surfsalin)
total_expand_xy_time$BSAL <- ifelse(is.na(total_expand_xy_time$botsalin), total_expand_xy_time$BSAL, total_expand_xy_time$botsalin)

#NAO and AMO data 
xdata_climate <- read.csv("~/Documents/ClimateOceanPlanning/R/NEFSC_GJAMM_GIT/Time/xdata_gridded.csv")
xdata_climate <- xdata_climate %>% dplyr::select(year, NAO_year, AMO_year, NAO_JFM)

xdata_climate <-xdata_climate %>% distinct()

total_expand_xy_time$year <- total_expand_xy_time$year.x
total_expand_xy_time <- left_join(total_expand_xy_time, xdata_climate, by=c("year"))



```

##new data
```{r}
xdata <- total_expand_xy_time %>% dplyr::select(time, depth, BENHAB, SBFDESED, SEDIMENT, SBFDEPTH, SBF_GRP, SLOPE, LPI, SUBREGION2, SSAL, BSAL, SST, BT, LATITUDE.x, LONGITUDE.x, AMO_year, NAO_year, NAO_JFM, myid, time, stratum)
#adding a group column 
xdata$groups <- as.factor(xdata$stratum)

spp_class <- read.csv("spp_by_year_selected.csv")
spp_class$SCINAME <- gsub(pattern = " ", replacement = ".", x = spp_class$SCINAME)
#spp_class <- subset(spp_class, spp_class$type=="fish")
specnames <- as.vector(spp_class$SCINAME)


ydata <- total_expand_xy_time[,specnames]
total_gridded <- cbind(ydata, xdata)
write.csv(total_gridded, "total_gridded.csv")
write.csv(xdata, "xdata_gridded.csv")
write.csv(ydata, "ydata_gridded.csv")
```
Note...there is a lot of missing xdata before 1992. Hycom (salinity and sst) starts in 1992. We could add AVHRR sst data (already downloaded from GEE)  but that doesn't have any salinity. We could also just start at 1992 and loose 8 years of the dataset. For now, I've kept the data as is (NAs with sal and sst before 1992)



```{r}




```

#Start here 
##load data 
##fill missing times
```{r, eval = F}
xdata <- read.csv("~/Documents/ClimateOceanPlanning/R/NEFSC_GJAMM_GIT/Time/xdata_gridded.csv")


xdata <- xdata %>% dplyr::select(-X)

xdata <- xdata %>% rename(times = time)

ydata <- read.csv("~/Documents/ClimateOceanPlanning/R/NEFSC_GJAMM_GIT/Time/ydata_gridded.csv")
ydata <- ydata %>% dplyr::select(-X)
ycommon <- gjamTrimY(ydata, 100, OTHER=F)$y 
specnames <- colnames(ycommon)

timeCol   <- 'times'
groupCol  <- 'groups'
groupVars <- c( 'groups' )
edata <- matrix(1,ncol=length(specnames), nrow=nrow(xdata))
colnames(edata) <- specnames
edata <- as.data.frame(edata)
ydata <- as.data.frame(ycommon)
xdata <- as.data.frame(xdata)

#I don't know what to do with fillmeans. If I have ydata as NA and fillmeans = true when I get down to running gjam I get a verbose error? If its zero and fill means is true I get a verbose error. If its 0 and fillmeans is false same error. If its 1 and fillmeans is false it works (same with 1 and fillmeans =T). it also works if the missing ydata is .1  : 
#Error in .gjamMissingValues(xl, y, factorRho$factorList, typeNames) : 
  #argument "verbose" is missing, with no default
ydata[is.na(ydata)] <- .0001
tmp <- gjamFillMissingTimes(xdata, ydata, edata, groupCol, timeCol,
                            FILLMEANS = F, groupVars = groupVars,
                            typeNames = 'DA', missingEffort =.1) 
#take time one and divide it by 10 for the prior. 

xdata  <- tmp$xdata
ydata  <- tmp$ydata
edata  <- tmp$edata
tlist  <- tmp$timeList
snames <- colnames(ydata)
trueValues <- tmp$trueValues

S <- length(specnames)

effort <- list(columns = 1:S, values =  edata)
```

`tlist` is a `list` that holds bookkeeping objects used for vectorized operations.  I would now replace the missing observations in `xdata` with known values for those groups and years, or I could leave them as `NA` in which case they will be imputed as in [gjam](http://rpubs.com/jimclark/551105).

The `list effort` is explained in `help(gjam)`.


##Prior distributions for coefficient matrices

Here is code to set up priors.  `rhoPrior` is a list indicating `lo` and `hi` values for the growth rate, which is change per time increment.  Again, growth rate `rho` only includes an `intercept`.  The density-independent growth rate is given a wide prior values of $\pm 30\%$ per time increment: Prior is Flat over this interval. 

```{r, eval = T}
rhoPrior  <- list(lo = list(intercept = -.3), 
                  hi = list(intercept = .3) ) 
print(rhoPrior)

```

The prior parameter values are organized in a `list` by the `function gjamTimePrior`.  It needs a `priorList` which includes `formulaRho` and `rhoPrior`.  In this simulator `rhoPrior` is restricted to an intercept, which corresponds to the `formula ~ ``:

```{r, eval = F}
names(xdata) = gsub(pattern = "_", replacement = "", x = names(xdata))

priorList <- list( formulaRho = as.formula(~ 1), rhoPrior = rhoPrior)

tmp <- gjamTimePrior( xdata, ydata, edata, priorList)


timeList <- mergeList(tlist, tmp)

```

In the last line I appended the `list tmp` generated by `gjamTimePrior` to my `timeList`.

Here are model fitting and plots using [gjam](http://rpubs.com/jimclark/551105):

```{r, eval = F}
modelList <- list(typeNames = 'CA', ng = 100, burnin = 50,  
                  timeList = timeList, verbose=T) 


outputAR <- gjam(~ depth + SST + SSAL + SEDIMENT + AMOyear, xdata=xdata, ydata=ydata, modelList=modelList)

```


Here are plots, which I've opted to deposit as `.pdf` files (`SAVEPLOTS = T`) in a folder `outFolder = gjamOutputAR`:

```{r, eval = F}
outFolder <- 'gjamOutputAR'
plotPars  <- list(PLOTALLY=T, #trueValues = ydata, 
                 SAVEPLOTS = F, outFolder = outFolder)
##getting an error with trueValues here 
gjamPlot(outputAR, plotPars)
save(outputAR, file = paste( outFolder, '/output.rdata', sep=''))
```

Here are MCMC chains:

```{r archains, echo=F, out.width = "45%", fig.cap = "MCMC chains for the AR model converge qu9ckly."}
knitr::include_graphics("gjamOutputAR/rhoChains.pdf")
knitr::include_graphics("gjamOutputAR/corChains.pdf")
```


The growth rates are recovered from the fitted model:

```{r arTrueVsPars, echo=F, out.width = "45%", fig.cap = "Parameter recovery for the AR model."}
knitr::include_graphics("gjamOutputAR/trueVsPars.pdf")
```

The fitted model predicts the data:

```{r arYpred, echo=F, out.width = "55%", fig.cap = "Data prediction for the AR model."}
knitr::include_graphics("gjamOutputAR/yPredBySpec_1.pdf")
```

##AR with movement responding to environment

This example couples density-independent growth (`termR`) with environmental variation in movement (`termB`).  The `logical` variable `termA` is again `FALSE`, because this model still does not include species interactions:

```{r, eval = T}

# specify design
S     <- 90        # no. species
nsite <- 71       # no. time series
ntime <- 50       # mean no. of time steps in a series
obsEffort <- 1    # full census

termB <- TRUE     # include immigration/emigration term XB
termR <- TRUE     # include DI population growth term VL
termA <- FALSE    # include DD spp interaction term UA
```

Simulated data include `Q = 3` predictors that will be named `"intercept", "x2", "x3"`.

```{r, eval = T}

seed <- 999
set.seed( seed )
tmp <- gjamSimTime(S, Q = 3, nsite, ntime, termB, termR, termA, 
                   obsEffort = obsEffort, PLOT = T)
xdata  <- tmp$xdata
ydata  <- tmp$ydata
edata  <- tmp$edata
groups <- tmp$groups
times  <- tmp$times
#wstar  <- tmp$wstar
trueValues <- tmp$trueValues
formula <- tmp$formula
```

Here I define groups and times, and I fill missing values:

```{r, eval = F}

xdata <- read.csv("~/Documents/ClimateOceanPlanning/R/NEFSC_GJAMM_GIT/Time/xdata_gridded.csv")
xdata <- xdata %>% dplyr::select(-X)
xdata <- xdata %>% rename(times = time)
xdata <- xdata %>% rename(groups = group)
ydata <- read.csv("~/Documents/ClimateOceanPlanning/R/NEFSC_GJAMM_GIT/Time/ydata_gridded.csv")
ydata <- ydata %>% dplyr::select(-X)
ycommon <- gjamTrimY(ydata, 100, OTHER=F)$y 
specnames <- colnames(ycommon)


timeCol   <- 'times'
groupCol  <- 'groups'
groupVars <- c( 'groups' )
tmp <- gjamFillMissingTimes(xdata, ydata, edata, groupCol, timeCol,
                            FILLMEANS = F, groupVars = groupVars,
                            typeNames = 'DA', missingEffort = .1)    
xdata <- tmp$xdata
ydata <- tmp$ydata
edata <- tmp$edata
tlist <- tmp$timeList
snames   <- colnames(ydata)

# fill for trueValues
#wTrue <- ydata/edata
#wTrue[ rownames(trueValues$w),] <- trueValues$w

effort <- list(columns = 1:S, values = edata)

```

Here are prior parameter values.  The `list betaPrior` holds `lo` and `hi` values for `intercept` and `x3` (uniformative).  The variable `x2` is unspecified, so it will be assigned bounds the exclude extreme values.


##mydata
```{r, eval = F}

betaPrior <- list(lo = list(intercept = -Inf, x3 = -Inf), 
                  hi = list(intercept = Inf, x3 = Inf) )
rhoPrior  <- list(lo = list(intercept = -.3), hi = list(intercept = .3) )

names(xdata) = gsub(pattern = "_", replacement = "", x = names(xdata))

priorList <- list( formulaBeta = ~ depth + SST + SSAL + SEDIMENT + AMOyear, formulaRho = as.formula(~ 1),  
                   betaPrior = betaPrior, rhoPrior = rhoPrior)
tmp <- gjamTimePrior( xdata, ydata, edata, priorList)


timeList <- mergeList(tlist, tmp)
```



Here is model fitting:

```{r, eval = F}

modelList <- list(typeNames = 'DA', ng = 100, burnin = 50,  
                  timeList = timeList, effort = effort) 
outputARX <- gjam(formula, xdata=xdata, ydata=ydata, modelList=modelList)
```

Here are some plots that will be saved in a folder:

```{r, eval = F}
plotPars <- list(PLOTALLY=T, trueValues = trueValues, SAVEPLOTS = T, 
                 outFolder = 'gjamOutputARX')
gjamPlot(outputARX, plotPars)
save(outputARX, file = 'gjamOutputARX/output.rdata')
```


```{r arxTrueVsPars, echo=F, out.width = "45%", fig.cap = "Parameter recovery for the AR model with movement."}
knitr::include_graphics("gjamOutputARX/trueVsPars.pdf")
```

```{r arxYpred, echo=F, out.width = "45%", fig.cap = "Data prediction."}
knitr::include_graphics("gjamOutputARX/yPredBySpec_1.pdf")
```



#A small food web

A dynamic community is simulated by specifying species pairs that are predator-prey (`predPrey`), that do not affect one another (`zeroAlpha`), or that compete (the default).  The function `foodWebDiagram` draws the food web:


```{r}

# specify design
S     <- 6     # no. species
nsite <- 10    # no. time series
ntime <- 100
obsEffort <- 1 # full census

termB <- FALSE    # include immigration/emigration term XB
termR <- TRUE     # include DI population growth term VL
termA <- TRUE     # include DD spp interaction term UA

predPrey1  <- rbind( c(1, 3), c(1, 4), c(2, 3), c(2, 4) )   # second position is prey of first 
zeroAlpha1 <- rbind( c(1, 2), c(2, 1),          # second position does not affect first
                    c(1, 5), c(5, 1),
                    c(2, 5), c(5, 2),
                    c(1, 6), c(6, 1),
                    c(2, 6), c(6, 2))                     

library(DiagrammeR)
foodWebDiagram(S, predPrey = predPrey1, zeroAlpha = zeroAlpha1)
#competition is the default assumption
```

In this diagram, red arrows are negative (predation), blue are positive (prey effect on predator), and brown arrows are (negative) competition.  Here is a simulation:

```{r, eval = F}

seed <- 999
set.seed( seed )
tmp <- gjamSimTime(S, Q = 0, nsite, ntime, termB, termR, termA, 
                   obsEffort = obsEffort, predPrey, zeroAlpha, PLOT = T)
xdata  <- tmp$xdata
ydata  <- tmp$ydata
edata  <- tmp$edata
groups <- tmp$groups
times  <- tmp$times
trueA  <- tmp$trueValues
formula <- tmp$formula

print( tmp$wdata )   # show eigenvalues and equilibrium abundances
```

This stable community has eigenvalues for `alpha` with all negative parts and equilibrium abundances that are positive.  Here I fill missing values:

```{r, eval = F}

timeCol   <- 'times'
groupCol  <- 'groups'
groupVars <- c( 'groups' )
tmp <- gjamFillMissingTimes(xdata, ydata, edata, groupCol, timeCol,
                            FILLMEANS = T, groupVars = groupVars,
                            typeNames = 'DA', missingEffort = .1)    
xdata <- tmp$xdata
ydata <- tmp$ydata
edata <- tmp$edata
tlist <- tmp$timeList
snames   <- colnames(ydata)

#legend('topright', snames, text.col = colF(S), ncol = 2, bty='n')

#wTrue <- ydata/edata
#wTrue[ rownames(trueA$w),] <- trueA$w
effort <- list(columns = 1:S, values = edata)

```

I set wide prior on DI population growth rate (up to 30% increase per year) and interaction coefficients.  In `alphaSign` I specify the sign of interactions in for the interaction matrix $\mathbf{\alpha}$ as (-1, 0, 1) to indicate negative, no interaction, and positive, respectively.

```{r, eval = F}

rhoPrior <- list(lo = list(intercept = 0), hi = list(intercept = .3) )

alphaSign  <- matrix(-1, S, S)
colnames(alphaSign) <- rownames(alphaSign) <- colnames(ydata)
alphaSign[ predPrey ]  <- 1
alphaSign[ zeroAlpha ] <- 0
  
priorList <- list( formulaRho = as.formula(~ 1),
                   rhoPrior = rhoPrior, alphaSign = alphaSign)
                   
tmp <- gjamTimePrior( xdata, ydata, edata, priorList )

timeList <- mergeList(tlist, tmp)
```


Here is model fitting:

```{r, eval = F}

modelList <- list(typeNames = 'DA', ng = 10000, burnin = 5000,  
           timeList = timeList, effort = effort) 

outputA <- gjam(formula, xdata=xdata, ydata=ydata, modelList=modelList)
```

Here are plots:

```{r, eval = F}
plotPars <- list(PLOTALLY=T, trueValues = trueA, SAVEPLOTS = T,
                 outFolder = 'gjamOutputA')
.gjamPlot(outputA, plotPars)
save(outputA, file = 'gjamOutputA/output.rdata')
```

Here are plots:

```{r aTrueVsPars, echo=F, out.width = "45%", fig.cap = "Parameter recovery for the AR model."}
knitr::include_graphics("gjamOutputA/trueVsPars.pdf")
```


```{r aYpred, echo=F, out.width = "55%", fig.cap = "Data prediction for the AR model."}
knitr::include_graphics("gjamOutputA/yPredBySpec_1.pdf")
```

Mean estimates for the interaction matrix $\mathbf{\alpha}$ are available in `outputA$parameters$alphaMu`.  Standard errors are in `outputA$parameters$alphaSe`.  Eigenvalues are in `outputA$parameters$alphaEigen`.

##My data 
```{r}

spp_class <- read.csv("spp_by_year_selected.csv")
#spp_class$SCINAME <- gsub(pattern = " ", replacement = ".", x = spp_class$SCINAME)
#spp_class <- subset(spp_class, spp_class$type=="fish")
specnames <- as.vector(spp_class$SCINAME)


#upload food web data 
spp <- read.csv("~/Documents/ClimateOceanPlanning/Datasets/food web/8083_FHDBS_Data/FHSPECIES.csv")
#diet_pred <- read.csv("~/Documents/ClimateOceanPlanning/Datasets/food web/8083_FHDBS_Data/FHPD.csv")
diet_prey <- read.csv("~/Documents/ClimateOceanPlanning/Datasets/food web/8083_FHDBS_Data/FHPYL.csv")
#diet_prey_length <- read.csv("~/Documents/ClimateOceanPlanning/Datasets/food web/8083_FHDBS_Data/FHPY.csv")
spp$pred_SCINAME <- spp$SCINAME
spp$pred_COMNAME <- spp$COMNAME

diet_prey <- left_join(diet_prey, spp, by=c("SVSPP"))

diet_prey <- diet_prey %>% dplyr::select(pred_SCINAME, PYNAM)
#lets find out which prey made up the highest proportion of each predators diet. 
Mode <- function(x) {
 ux <- unique(x)
 ux[which.max(tabulate(match(x, ux)))]
}

diet_prey_mode <- diet_prey %>% group_by(pred_SCINAME) %>% summarise(PREY_mode = Mode(PYNAM))

diet_prey$num <- 1
diet_prey_test <- diet_prey %>% group_by(pred_SCINAME, PYNAM) %>% summarise(count = sum(num))
diet_prey <- diet_prey_test
diet_prey <- subset(diet_prey,diet_prey$PYNAM != "FISH")
diet_prey <- subset(diet_prey,diet_prey$PYNAM != "FISH LARVAE")
diet_prey <- diet_prey %>% group_by(pred_SCINAME) %>% mutate(percent = count/sum(count))


spp_selected <- read.csv("spp_by_year_selected.csv")
specnames <- as.vector(spp_selected$SCINAME)

diet_prey_small <- diet_prey[diet_prey$pred_SCINAME %in% specnames,]

diet_prey_smaller <- diet_prey_small[diet_prey_small$PYNAM %in% specnames,]

diet_prey_smallest <- subset(diet_prey_smaller, diet_prey_smaller$count >30) #use this
write.csv(diet_prey_smallest, "PredPrey.csv")


predPrey  <- diet_prey_smaller[2:3]   # second position is prey of first 
colnames(predPrey) <- c("V1", "V2")
#remove columns that prey on themselves
predPrey$V1 <- as.character(predPrey$V1)
predPrey$V2 <- as.character(predPrey$V2)

predPrey <- predPrey[predPrey$V1 !=predPrey$V2,]
predPrey$comb_effect <-  paste(predPrey$V1, predPrey$V2, sep = "-")


#zero alpha 
#first get unique combinations of all the species 
unique_spec <- expand.grid(spp_selected$SCINAME,spp_selected$SCINAME)
unique_spec$comb_noeffect <- paste(unique_spec$Var1, unique_spec$Var2, sep = "-")
unique_spec$comb_noeffect2 <- paste(unique_spec$Var2, unique_spec$Var1, sep = "-")

'%ni%' <- Negate('%in%')
no_effect <- subset(unique_spec, !(unique_spec$comb_noeffect %in% predPrey$comb_effect))
no_effect2 <- subset(no_effect, !(no_effect$comb_noeffect2 %in% predPrey$comb_effect))


no_effect2$Var1 <- as.character(no_effect2$Var1)
no_effect2$Var2 <- as.character(no_effect2$Var2)

no_effect <- no_effect2[no_effect2$Var1 !=no_effect2$Var2,]

no_effect <- no_effect[1:2]

#need to get out the unique pairs 
no_effect <- no_effect[no_effect$b !=no_effect$a,]

library(dplyr)
no_effect <- no_effect %>%
  distinct(comb_noeffect,comb_noeffect2)

#okay so the problem is these columns should represent no effect but have some duplicates (i.e species one has no effect on species 2 and that relationship is written twice)

```

##mydata guilds 
```{r}
spp_selected <- read.csv("spp_by_year_selected.csv")

#prey guilds 
guild0 <- subset(spp_selected, spp_selected$order == "oegopsida"  | spp_selected$order == "myopsida")
guild0 <- as.vector(guild0$SCINAME)

guild1 <- subset(spp_selected, spp_selected$order == "clupeiformes") 
guild1 <- as.vector(guild1$SCINAME)

guild2 <- subset(spp_selected, spp_selected$order == "decapods") 
guild2 <- as.vector(guild2$SCINAME)

#predator guilds 
guild3 <- subset(spp_selected, spp_selected$order == "perciformes") 
guild3 <- as.vector(guild3$SCINAME)

guild4 <- subset(spp_selected, spp_selected$order == "gadiformes") 
guild4 <- as.vector(guild4$SCINAME)

guild5 <- subset(spp_selected, spp_selected$order == "pleuronectiformes") 
guild5 <- as.vector(guild5$SCINAME)

guild6 <- subset(spp_selected, spp_selected$order == "rajiformes"  | spp_selected$order == "myliobatiformes") 
guild6 <- as.vector(guild6$SCINAME)

guild7 <- subset(spp_selected, spp_selected$order == "scorpaeniformes") 
guild7 <- as.vector(guild7$SCINAME)

guild8 <- subset(spp_selected, spp_selected$order == "carcharhiniformes"  | spp_selected$order == "squantiniformes" | spp_selected$order == "squaliformes") 
guild8 <- as.vector(guild8$SCINAME)

order_list <- c("carcharhiniformes",  "squantiniformes" , "squaliformes" , "scorpaeniformes" ,"scorpaeniformes","rajiformes","myliobatiformes" ,"pleuronectiformes"  , "pleuronectiformes","gadiformes"  ,"gadiformes" ,"perciformes" , "decapods" , "clupeiformes" , "clupeiformes" ,"oegopsida" ,"myopsida")

sppnames <- subset(spp_selected, spp_selected$order %in% order_list) 
sppnames <- as.vector(sppnames$SCINAME)
#guild 3 eats guild 0,1,2
#guild 4 eats 1,2
#guild 5 eats 1,2
#guild 6 eats 1,2
#guild 7 eats 1,2
#guild 8 eats 1, 3, 4, 5, 7

#which means guild 3,4,5,6,7 are competators 


S <- length(sppnames)
S <- length(specnames)

guildList <- list(guild0 = match(guild0, sppnames),
                  guild1 = match(guild1, sppnames), 
                  guild2 = match(guild2, sppnames), 
                  guild3 = match(guild3, sppnames), 
                  guild4 = match(guild4, sppnames), 
                  guild5 = match(guild5, sppnames), 
                  guild6 = match(guild6, sppnames), 
                  guild7 = match(guild7, sppnames), 
                  guild8 = match(guild8, sppnames), 
                  ) # competition groups

foodWebDiagram(S, guildList, label = snames, intraComp = 1:S)

fromTo <- foodWebDiagram(S, guildList, PLOT = F)



```
## mydata filled in

I set wide prior on DI population growth rate (up to 30% increase per year) and interaction coefficients.  In `alphaSign` I specify the sign of interactions in for the interaction matrix $\mathbf{\alpha}$ as (-1, 0, 1) to indicate negative, no interaction, and positive, respectively.

```{r, eval = F}

rhoPrior <- list(lo = list(intercept = 0), hi = list(intercept = .3) )

alphaSign  <- matrix(-1, S, S)
colnames(alphaSign) <- rownames(alphaSign) <- specnames
alphaSign[ predPrey ]  <- 1
alphaSign[ zeroAlpha ] <- 0

```

###new 
```{r}
#load data 
spp_class <- read.csv("spp_by_year_selected.csv")
specnames <- as.vector(spp_class$SCINAME)

total_expand_xy_time <- read.csv("~/Documents/ClimateOceanPlanning/R/NEFSC_GJAMM_GIT/Time/total_expand_xy_time.csv")

xdata <- read.csv("~/Documents/ClimateOceanPlanning/R/NEFSC_GJAMM_GIT/Time/xdata_gridded.csv")
xdata <- xdata %>% dplyr::select(-X.1)
xdata <- xdata %>% rename(times = time)
colnames(xdata) <- gsub(pattern = "_", replacement = "", x = colnames(xdata))
xdata$month <- total_expand_xy_time$month.x

ydata <- read.csv("~/Documents/ClimateOceanPlanning/R/NEFSC_GJAMM_GIT/Time/ydata_gridded.csv")
ydata <- ydata %>% dplyr::select(-X)
ydata[is.na(ydata)] <- 0

ydata <- ydata %>% select_if(colSums(.) > 14)

specnames <- colnames(ydata)

alphaSign <- read.csv("alphaSign_filled.csv")
alphaSign <- alphaSign %>% dplyr::select(-X)
rownames(alphaSign) <- colnames(alphaSign)

alphaSign <- alphaSign[,colnames(alphaSign) %in% specnames]
alphaSign <- alphaSign[rownames(alphaSign) %in% specnames,]
specnames <- colnames(alphaSign)

ydata <- ydata[,colnames(ydata) %in% specnames]


#create edata
edata <- matrix(1,ncol=length(specnames), nrow=nrow(xdata))
colnames(edata) <- specnames
edata <- as.data.frame(edata)

write.csv(edata, "edata.csv", row.names=F)
write.csv(ydata, "ydata.csv", row.names=F)
write.csv(xdata, "xdata.csv", row.names=F)


```

###visualize food web 
```{r}
PredPrey <- read.csv("~/Documents/ClimateOceanPlanning/R/NEFSC_GJAMM_GIT/Time/PredPrey.csv")
predPrey  <- PredPrey[1:2]   # second position is prey of first 
colnames(predPrey) <- c("V1", "V2")
#remove columns that prey on themselves
predPrey$V1 <- as.character(predPrey$V1)
predPrey$V2 <- as.character(predPrey$V2)

predPrey <- predPrey[predPrey$V1 !=predPrey$V2,]
predPrey$comb_effect <-  paste(predPrey$V1, predPrey$V2, sep = "-")


#zero alpha 
#first get unique combinations of all the species 
spp_selected <- read.csv("spp_by_year_selected.csv")
unique_spec <- expand.grid(spp_selected$SCINAME,spp_selected$SCINAME)
unique_spec$comb_noeffect <- paste(unique_spec$Var1, unique_spec$Var2, sep = "-")
unique_spec$comb_noeffect2 <- paste(unique_spec$Var2, unique_spec$Var1, sep = "-")

'%ni%' <- Negate('%in%')
no_effect <- subset(unique_spec, !(unique_spec$comb_noeffect %in% predPrey$comb_effect))
no_effect2 <- subset(no_effect, !(no_effect$comb_noeffect2 %in% predPrey$comb_effect))

  
no_effect2$Var1 <- as.character(no_effect2$Var1)
no_effect2$Var2 <- as.character(no_effect2$Var2)

no_effect <- no_effect2[no_effect2$Var1 !=no_effect2$Var2,]
no_uni <- no_effect %>%
 group_by(grp = paste0(pmin(Var1, Var2), pmax(Var1, Var2))) %>%
 slice(1) %>%
 ungroup()

zeroAlpha <- no_uni[1:2]
colnames(zeroAlpha) <- c("Var1", "Var2")

library(DiagrammeR)
S <- 104
predPrey <- predPrey[1:2]
colnames(predPrey) <- c("Var1", "Var2")

#just get out the ones we are modeling
predPrey$Var1 <- gsub(pattern = " ", replacement = ".", x = predPrey$Var1)
predPrey$Var2 <- gsub(pattern = " ", replacement = ".", x = predPrey$Var2)

predPrey <- predPrey[predPrey$Var1 %in% specnames,]
predPrey <- predPrey[predPrey$Var2 %in% specnames,]

zeroAlpha$Var1 <- gsub(pattern = " ", replacement = ".", x = zeroAlpha$Var1)
zeroAlpha$Var2 <- gsub(pattern = " ", replacement = ".", x = zeroAlpha$Var2)

zeroAlpha <- zeroAlpha[zeroAlpha$Var1 %in% specnames,]
zeroAlpha <- zeroAlpha[zeroAlpha$Var2 %in% specnames,]


foodWebDiagram(S, predPrey = predPrey, PLOT = TRUE, layout = 'rr')
#competition is the default assumption



#get just the species with pred prey interactions 
spec2 <- unique(unlist(predPrey))
zeroAlpha1 <- zeroAlpha[zeroAlpha$Var1 %in% spec2,]
zeroAlpha1 <- zeroAlpha1[zeroAlpha1$Var2 %in% spec2,]

spec4 <- as.data.frame(spec2)
spec4$SCINAME <- spec4$spec2
spp_selected <- read.csv("spp_by_year_selected.csv")
spp_selected_2 <- spp_selected %>% dplyr::select(SCINAME, COMNAME)
spp_selected_2$SCINAME <- gsub(pattern = ' ', replacement = ".", x = spp_selected_2$SCINAME)

spec5 <- left_join(spec4, spp_selected_2, by = "SCINAME")
spec5 <- as.vector(spec5$COMNAME)

spec3 <- gsub(pattern = ' ', replacement = "\n", x = spec5)



S = 44 
foodWebDiagram(S, predPrey = predPrey,zeroAlpha = zeroAlpha1, label = spec3, PLOT = TRUE, layout = 'rxr')



```
In this diagram, red arrows are negative (predation), blue are positive (prey effect on predator). I've messed with the gjamTime Functions and added "fromTo <- expand.grid(spec2,spec2)  #I changed this t <- .pasteCols( fromTo )#I changed this" to change the species numbers etc. I may only need to show one way predation. To show the prey arrows change ecol[ wt ] <- mycol to ecol[ wt ] <- "blue"



```{r}
t_col <- function(color, percent = 50, name = NULL) {
  #      color = color name
  #    percent = % transparency
  #       name = an optional name for the color

## Get RGB values for named color
rgb.val <- col2rgb(color)

## Make new color using input color as base and alpha set by transparency
t.col <- rgb(rgb.val[1], rgb.val[2], rgb.val[3],
             max = 255,
             alpha = (100 - percent) * 255 / 100,
             names = name)

## Save the color
invisible(t.col)
}
mycol <- t_col("pink", perc = 99, name = "lt.pink")
```

##run it
###catch per 1000 effort 
```{r}
#load data 
spp_class <- read.csv("spp_by_year_selected.csv")
specnames <- as.vector(spp_class$SCINAME)

xdata <- read.csv("~/Documents/ClimateOceanPlanning/R/NEFSC_GJAMM_GIT/Time/xdata_gridded.csv")
xdata <- xdata %>% dplyr::select(-X.1)
xdata <- xdata %>% rename(times = time)
colnames(xdata) <- gsub(pattern = "_", replacement = "", x = colnames(xdata))

#lets also add a column for sediment size 
xdata$SEDSIZE <- ifelse(xdata$SEDIMENT ==  '0 - 0.03 Silt/Mud', .03, 
                        ifelse(xdata$SEDIMENT ==  '0.03 - 0.17 Sand', .17,
                               ifelse(xdata$SEDIMENT ==  '0.17 - 0.35 Sand',.35, 
                                      ifelse(xdata$SEDIMENT ==  '0.35 - 0.36 Sand', .36,
                                             ifelse(xdata$SEDIMENT ==  '0.36 - 0.48 Sand', .48, ifelse(xdata$SEDIMENT ==  '0.48+ Coarse Sand to Gravel',.50,NA))))))




ydata <- read.csv("~/Documents/ClimateOceanPlanning/R/NEFSC_GJAMM_GIT/Time/ydata_gridded.csv")
ydata <- ydata %>% dplyr::select(-X)
ydata <- ydata*1000
ydata[is.na(ydata)] <- 0

ydata <- ydata %>% select_if(colSums(.) > 14)

specnames <- colnames(ydata)

alphaSign <- read.csv("alphaSign_filled.csv")
alphaSign <- alphaSign %>% dplyr::select(-X)
rownames(alphaSign) <- colnames(alphaSign)

alphaSign <- alphaSign[,colnames(alphaSign) %in% specnames]
alphaSign <- alphaSign[rownames(alphaSign) %in% specnames,]
specnames <- colnames(alphaSign)

ydata <- ydata[,colnames(ydata) %in% specnames]


#create edata
edata <- matrix(1,ncol=length(specnames), nrow=nrow(xdata))
colnames(edata) <- specnames
edata <- as.data.frame(edata)


#alphaSign to just species I'm using now

alphaSign <- alphaSign[,colnames(alphaSign) %in% specnames]
alphaSign <- alphaSign[rownames(alphaSign) %in% specnames,]
specnames <- colnames(alphaSign)


#fill missing times 
timeCol   <- 'times'
groupCol  <- 'groups'
groupVars <- c( 'groups' )
tmp <- gjamFillMissingTimes(xdata, ydata, edata, groupCol, timeCol,
                            FILLMEANS = T, groupVars = groupVars,
                            typeNames = 'CA', missingEffort = 1)    
xdata <- tmp$xdata
ydata <- tmp$ydata
edata <- tmp$edata
tlist <- tmp$timeList
snames   <- colnames(ydata)
trueE <- tmp$trueValues

colnames(xdata) <- c("insert","groups","times","X","times2","depth","BENHAB","SBFDESED", "SEDIMENT","SBFDEPTH","SBFGRP","SLOPE","LPI","SUBREGION2","SSAL", "BSAL","SST","BT"  , "LATITUDE.x","LONGITUDE.x","AMOyear" ,"NAOyear","NAOJFM","myid","stratum","groups2", "SEDSIZE")

effort <- list(columns = 1:length(snames), values = edata)


#set priors

# effect on species growth.
# We are trying to estimate the amount of population growth that is affected by 
# each covariate. We only include covariates in the rho.form if we think they 
# have an effect. 'Lo' of 0 means we think it will have a  positive effect. 'hi' 
# of 0 is a negative effect. For this example, I think that NAO and AMO and SST have an effect on population growth so I will set a wide prior. 
rhoPrior <- list(lo = list(intercept = -.2, SST = -2, NAOJFM = -2, AMOyear = -2), hi = list(intercept = .2,SST = 2, NAOJFM = 2, AMOyear = 2) )
#make tighter priors here 

#effect on e/imigration
# We are trying to estimate the amount of em-/immigration into/out of each grid
# that is affected by each covariate. 'Lo' of 0 means we think it will have a 
# positive effect. We leave it to be figured out by the data. 
betaPrior <- list(lo = list(intercept = -2), 
                  hi = list(intercept = 2) )

#take out some predictors in beta 
priorList <- list( formulaBeta = ~ depth + SST + SSAL + SEDSIZE+ NAOJFM + AMOyear, formulaRho = as.formula(~  NAOJFM + AMOyear + SST ),  
                   betaPrior = betaPrior, rhoPrior = rhoPrior, alphaSign = alphaSign)


tmp <- gjamTimePrior( xdata, ydata, edata, priorList )

timeList <- mergeList(tlist, tmp)

modelList <- list(typeNames = 'CA', ng = 1000, burnin = 500,  
           timeList = timeList, effort = effort) 

#try one or two variables here (these are what effects movement)
outputA2 <- gjam(~ depth + SST + SSAL + SEDSIZE+ NAOJFM + AMOyear, xdata=xdata, ydata=ydata, modelList=modelList)

plotPars <- list(PLOTALLY=T, SAVEPLOTS = T, SMALLPLOTS = T, GRIDPLOTS = T, width = 10, height = 10,
                 outFolder = 'gjamOutputXRA_me')
gjamPlot(outputA2, plotPars)
save(outputA2, file='gjamOutputXRA_me/output.rdata')

#note I get a dimensionality error when I try and change the rho formula priors for each variable

```


###tighter priors, fewer betas 
I'll try taking out some of the betas (only sediment, sal, depth), and focusing on rho and alpha here. I dont think sediment or depth will effect population growth rates at all. The model really doesn't like having salinity (or depth) in the rho formula (get an error that it's computationally similar). I wonder if it's because there are too many NAs? Salinity doesn't vary too much either. I took SST out of the betas here 
```{r}
#set priors


# effect on species growth.
# We are trying to estimate the amount of population growth that is affected by 
# each covariate. We only include covariates in the rho.form if we think they 
# have an effect. 'Lo' of 0 means we think it will have a  positive effect. 'hi' 
# of 0 is a negative effect. For this example, I think that NAO and AMO and SST  have an effect on population growth so I will set a wide prior. 
rhoPrior <- list(lo = list(intercept = -.2, SST = -2, NAOJFM = -2, AMOyear = -2), hi = list(intercept = .2,SST = 2, NAOJFM = 2, AMOyear = 2) )
#make tighter priors here 

#effect on e/imigration
# We are trying to estimate the amount of em-/immigration into/out of each grid
# that is affected by each covariate. 'Lo' of 0 means we think it will have a 
# positive effect. We leave it to be figured out by the data. 
betaPrior <- list(lo = list(intercept = -2, SEDSIZE = -2, depth = -2, SSAL = -2), hi = list(intercept = 2, SEDSIZE = 2, depth = 2, SSAL = 2) )

#take out some predictors in beta 
priorList <- list( formulaBeta = ~ depth + SEDSIZE + SSAL, formulaRho = as.formula(~  NAOJFM + AMOyear + SST),  
                   betaPrior = betaPrior, rhoPrior = rhoPrior, alphaSign = alphaSign)


tmp <- gjamTimePrior( xdata, ydata, edata, priorList )

timeList <- mergeList(tlist, tmp)

modelList <- list(typeNames = 'CA', ng = 1000, burnin = 500,  
           timeList = timeList, effort = effort) 

#try one or two variables here (these are what effects movement)
outputR_1 <- gjam(~  depth + SEDSIZE + SSAL, xdata=xdata, ydata=ydata, modelList=modelList)

plotPars <- list(PLOTALLY=T, SAVEPLOTS = T, SMALLPLOTS = T, GRIDPLOTS = T,
                 outFolder = 'gjamOutputXRA_1')
gjamPlot(outputR_1, plotPars)
save(outputR_1, file='gjamOutputXRA_1/output.rdata')

#note I get a dimensionality error when I try and change the rho formula priors for each variable


```

###tighter priors, more betas 
I added SST into beta (still in rho). made a tighter prior. 

```{r}
#set priors


# effect on species growth.
# We are trying to estimate the amount of population growth that is affected by 
# each covariate. We only include covariates in the rho.form if we think they 
# have an effect. 'Lo' of 0 means we think it will have a  positive effect. 'hi' 
# of 0 is a negative effect. For this example, I think that NAO and AMO and SST  have an effect on population growth so I will set a wide prior. 
rhoPrior <- list(lo = list(intercept = -.2, SST = -2, NAOJFM = -2, AMOyear = -2), hi = list(intercept = .2,SST = 2, NAOJFM = 2, AMOyear = 2) )
#make tighter priors here 

#effect on e/imigration
# We are trying to estimate the amount of em-/immigration into/out of each grid
# that is affected by each covariate. 'Lo' of 0 means we think it will have a 
# positive effect. We leave it to be figured out by the data. 
betaPrior <- list(lo = list(intercept = -2, SEDSIZE = -2, depth = -2, SSAL = -2, SST = -2), hi = list(intercept = 2, SEDSIZE = 2, depth = 2, SSAL = 2, SST = -2) )

#take out some predictors in beta 
priorList <- list( formulaBeta = ~ depth + SEDSIZE + SSAL + SST, formulaRho = as.formula(~  NAOJFM + AMOyear + SST),  
                   betaPrior = betaPrior, rhoPrior = rhoPrior, alphaSign = alphaSign)


tmp <- gjamTimePrior( xdata, ydata, edata, priorList )

timeList <- mergeList(tlist, tmp)

modelList <- list(typeNames = 'CA', ng = 1000, burnin = 500,  
           timeList = timeList, effort = effort) 

#try one or two variables here (these are what effects movement)
outputR_2 <- gjam(~  depth + SEDSIZE + SSAL + SST, xdata=xdata, ydata=ydata, modelList=modelList)

plotPars <- list(PLOTALLY=T, SAVEPLOTS = T, SMALLPLOTS = T, GRIDPLOTS = T,
                 outFolder = 'gjamOutputXRA_2')
gjamPlot(outputR_2, plotPars)
save(outputR_2, file='gjamOutputXRA_2/output.rdata')

#note I get a dimensionality error when I try and change the rho formula priors for each variable


```


###tighter priors, all interactions 
I added all of the variables into beta. kept the same ones in rho. made a tighter prior. This should be similar to the 
```{r}
#set priors


# effect on species growth.
# We are trying to estimate the amount of population growth that is affected by 
# each covariate. We only include covariates in the rho.form if we think they 
# have an effect. 'Lo' of 0 means we think it will have a  positive effect. 'hi' 
# of 0 is a negative effect. For this example, I think that NAO and AMO and SST SSAL have an effect on population growth so I will set a wide prior. 
rhoPrior <- list(lo = list(intercept = -.2, SST = -2, NAOJFM = -2, AMOyear = -2), hi = list(intercept = .2,SST = 2, NAOJFM = 2, AMOyear = 2) )
#make tighter priors here 

#effect on e/imigration
# We are trying to estimate the amount of em-/immigration into/out of each grid
# that is affected by each covariate. 'Lo' of 0 means we think it will have a 
# positive effect. We leave it to be figured out by the data. 
betaPrior <- list(lo = list(intercept = -2, SST = -2, SEDSIZE = -2, depth = -2, SSAL = -2, AMOyear = -2, NAOJFM = -2), hi = list(intercept = 2,SST = 2, SEDSIZE = 2, depth = 2, SSAL = 2,AMOyear = 2, NAOJFM = 2) )

#add back climate predictors in beta 
priorList <- list( formulaBeta = ~ depth + SEDSIZE + SSAL + SST + NAOJFM + AMOyear, formulaRho = as.formula(~  NAOJFM + AMOyear + SST),  
                   betaPrior = betaPrior, rhoPrior = rhoPrior, alphaSign = alphaSign)


tmp <- gjamTimePrior( xdata, ydata, edata, priorList )

timeList <- mergeList(tlist, tmp)

modelList <- list(typeNames = 'CA', ng = 1000, burnin = 500,  
           timeList = timeList, effort = effort) 

#try one or two variables here (these are what effects movement)
outputRB_2 <- gjam(~  depth + SEDSIZE + SSAL + SST + NAOJFM + AMOyear , xdata=xdata, ydata=ydata, modelList=modelList)

plotPars <- list(PLOTALLY=T, SAVEPLOTS = T, SMALLPLOTS = T, GRIDPLOTS = T,
                 outFolder = 'gjamOutputXRA_3')
gjamPlot(outputRB_2, plotPars)
save(outputRB_2, file='gjamOutputXRA_3/output.rdata')

#note I get a dimensionality error when I try and change the rho formula priors for each variable


```


###seasonal model 

```{r}
total_expand_xy_time <- read.csv("~/Documents/ClimateOceanPlanning/R/NEFSC_GJAMM_GIT/Time/total_expand_xy_time.csv")

xdata <- read.csv("~/Documents/ClimateOceanPlanning/R/NEFSC_GJAMM_GIT/Time/xdata_gridded.csv")
xdata <- xdata %>% dplyr::select(-X.1)
xdata <- xdata %>% rename(times = time)
colnames(xdata) <- gsub(pattern = "_", replacement = "", x = colnames(xdata))
xdata$month <- total_expand_xy_time$month.x


#load data 
spp_class <- read.csv("spp_by_year_selected.csv")
specnames <- as.vector(spp_class$SCINAME)

#lets also add a column for sediment size 
xdata$SEDSIZE <- ifelse(xdata$SEDIMENT ==  '0 - 0.03 Silt/Mud', .03, 
                        ifelse(xdata$SEDIMENT ==  '0.03 - 0.17 Sand', .17,
                               ifelse(xdata$SEDIMENT ==  '0.17 - 0.35 Sand',.35, 
                                      ifelse(xdata$SEDIMENT ==  '0.35 - 0.36 Sand', .36,
                                             ifelse(xdata$SEDIMENT ==  '0.36 - 0.48 Sand', .48, ifelse(xdata$SEDIMENT ==  '0.48+ Coarse Sand to Gravel',.50,NA))))))




ydata <- read.csv("~/Documents/ClimateOceanPlanning/R/NEFSC_GJAMM_GIT/Time/ydata_gridded.csv")
ydata <- ydata %>% dplyr::select(-X)
ydata <- ydata*1000
ydata[is.na(ydata)] <- 0

ydata <- ydata %>% select_if(colSums(.) > 14)

specnames <- colnames(ydata)

alphaSign <- read.csv("alphaSign_filled.csv")
alphaSign <- alphaSign %>% dplyr::select(-X)
rownames(alphaSign) <- colnames(alphaSign)

alphaSign <- alphaSign[,colnames(alphaSign) %in% specnames]
alphaSign <- alphaSign[rownames(alphaSign) %in% specnames,]
specnames <- colnames(alphaSign)

ydata <- ydata[,colnames(ydata) %in% specnames]

#add a spring and fall column 
xdata$season <- ifelse(xdata$month < 7, "spring", "fall")
ydata$season <- xdata$season

xdata_spring <- subset(xdata, xdata$season=="spring")
ydata_spring <- subset(ydata, ydata$season=="spring")

xdata_fall <- subset(xdata, xdata$season=="fall")
ydata_fall <- subset(ydata, ydata$season=="fall")

ydata_fall <- ydata_fall %>% dplyr::select(-season)
ydata_spring <- ydata_spring %>% dplyr::select(-season)

```

####fall 
```{r}
#create edata
edata_fall <- matrix(1,ncol=length(specnames), nrow=nrow(xdata_fall))
colnames(edata_fall) <- specnames
edata <- as.data.frame(edata_fall)


#alphaSign to just species I'm using now

alphaSign <- alphaSign[,colnames(alphaSign) %in% specnames]
alphaSign <- alphaSign[rownames(alphaSign) %in% specnames,]
specnames <- colnames(alphaSign)


#fill missing times 
timeCol   <- 'times'
groupCol  <- 'groups'
groupVars <- c( 'groups' )
tmp <- gjamFillMissingTimes(xdata_fall, ydata_fall, edata_fall, groupCol, timeCol,
                            FILLMEANS = T, groupVars = groupVars,
                            typeNames = 'CA', missingEffort = 1)    
xdata <- tmp$xdata
ydata <- tmp$ydata
edata <- tmp$edata
tlist <- tmp$timeList
snames   <- colnames(ydata)
trueE <- tmp$trueValues

colnames(xdata) <- c("insert","groups","times","X","times2","depth","BENHAB","SBFDESED", "SEDIMENT","SBFDEPTH","SBFGRP","SLOPE","LPI","SUBREGION2","SSAL", "BSAL","SST","BT"  , "LATITUDE.x","LONGITUDE.x","AMOyear" ,"NAOyear","NAOJFM","myid","stratum","groups2", "month", "SEDSIZE", "season")

effort <- list(columns = 1:length(snames), values = edata)


#set priors

# effect on species growth.
# We are trying to estimate the amount of population growth that is affected by 
# each covariate. We only include covariates in the rho.form if we think they 
# have an effect. 'Lo' of 0 means we think it will have a  positive effect. 'hi' 
# of 0 is a negative effect. For this example, I think that NAO and AMO and SST have an effect on population growth so I will set a wide prior. 
rhoPrior <- list(lo = list(intercept = -2, SST = -2, NAOJFM = -2, AMOyear = -2), hi = list(intercept = 2,SST = 2, NAOJFM = 2, AMOyear = 2) )

#effect on e/imigration
# We are trying to estimate the amount of em-/immigration into/out of each grid
# that is affected by each covariate. 'Lo' of 0 means we think it will have a 
# positive effect. We leave it to be figured out by the data. 
betaPrior <- list(lo = list(intercept = -Inf, x3 = -Inf), 
                  hi = list(intercept = Inf, x3 = Inf) )

priorList <- list( formulaBeta = ~ depth + SST + SSAL + SEDSIZE+ NAOJFM + AMOyear, formulaRho = as.formula(~  NAOJFM + AMOyear + SST ),  
                   betaPrior = betaPrior, rhoPrior = rhoPrior, alphaSign = alphaSign)


tmp <- gjamTimePrior( xdata, ydata, edata, priorList )

timeList <- mergeList(tlist, tmp)

modelList <- list(typeNames = 'CA', ng = 10000, burnin = 5000,  
           timeList = timeList, effort = effort) 

outputA2_fall <- gjam(~ depth + SST + SSAL + SEDSIZE+ NAOJFM + AMOyear, xdata=xdata, ydata=ydata, modelList=modelList)

plotPars <- list(PLOTALLY=T, SAVEPLOTS = T,
                 outFolder = 'gjamOutputXRA_fall')
gjamPlot(outputA2_fall, plotPars)
save(outputA2_fall, file='gjamOutputXRA_me/output.rdata')

```

####spring 
```{r}
#create edata
edata_spring <- matrix(1,ncol=length(specnames), nrow=nrow(xdata_spring))
colnames(edata_spring) <- specnames
edata <- as.data.frame(edata_spring)


#alphaSign to just species I'm using now

alphaSign <- alphaSign[,colnames(alphaSign) %in% specnames]
alphaSign <- alphaSign[rownames(alphaSign) %in% specnames,]
specnames <- colnames(alphaSign)


#fill missing times 
timeCol   <- 'times'
groupCol  <- 'groups'
groupVars <- c( 'groups' )
tmp <- gjamFillMissingTimes(xdata_spring, ydata_spring, edata_spring, groupCol, timeCol,
                            FILLMEANS = T, groupVars = groupVars,
                            typeNames = 'CA', missingEffort = 1)    
xdata <- tmp$xdata
ydata <- tmp$ydata
edata <- tmp$edata
tlist <- tmp$timeList
snames   <- colnames(ydata)
trueE <- tmp$trueValues

colnames(xdata) <- c("insert","groups","times","X","times2","depth","BENHAB","SBFDESED", "SEDIMENT","SBFDEPTH","SBFGRP","SLOPE","LPI","SUBREGION2","SSAL", "BSAL","SST","BT"  , "LATITUDE.x","LONGITUDE.x","AMOyear" ,"NAOyear","NAOJFM","myid","stratum","groups2", "month", "SEDSIZE", "season")

effort <- list(columns = 1:length(snames), values = edata)


#set priors

# effect on species growth.
# We are trying to estimate the amount of population growth that is affected by 
# each covariate. We only include covariates in the rho.form if we think they 
# have an effect. 'Lo' of 0 means we think it will have a  positive effect. 'hi' 
# of 0 is a negative effect. For this example, I think that NAO and AMO and SST have an effect on population growth so I will set a wide prior. 
rhoPrior <- list(lo = list(intercept = -2, SST = -2, NAOJFM = -2, AMOyear = -2), hi = list(intercept = 2,SST = 2, NAOJFM = 2, AMOyear = 2) )

#effect on e/imigration
# We are trying to estimate the amount of em-/immigration into/out of each grid
# that is affected by each covariate. 'Lo' of 0 means we think it will have a 
# positive effect. We leave it to be figured out by the data. 
betaPrior <- list(lo = list(intercept = -Inf, x3 = -Inf), 
                  hi = list(intercept = Inf, x3 = Inf) )

priorList <- list( formulaBeta = ~ depth + SST + SSAL + SEDSIZE+ NAOJFM + AMOyear, formulaRho = as.formula(~  NAOJFM + AMOyear + SST ),  
                   betaPrior = betaPrior, rhoPrior = rhoPrior, alphaSign = alphaSign)


tmp <- gjamTimePrior( xdata, ydata, edata, priorList )

timeList <- mergeList(tlist, tmp)

modelList <- list(typeNames = 'CA', ng = 10000, burnin = 5000,  
           timeList = timeList, effort = effort) 

outputA2_spring <- gjam(~ depth + SST + SSAL + SEDSIZE+ NAOJFM + AMOyear, xdata=xdata, ydata=ydata, modelList=modelList)

plotPars <- list(PLOTALLY=T, SAVEPLOTS = T,
                 outFolder = 'gjamOutputXRA_spring')
gjamPlot(outputA2_spring, plotPars)
save(outputA2_spring, file='gjamOutputXRA_me/output.rdata')

```

###prediction
####new xdata

```{r}
library(ncdf4)
#sst
ncpath <- "~/Documents/Classes/course_lectures/ViaX/project/"
ncname <- "GFDL_8.5_SST"
ncfname <- paste(ncpath, ncname, ".nc", sep="")
ncin <- nc_open(ncfname)
print(ncin)
names(ncin$var)

anom_sst <- stack(ncfname, varname="anomaly")
plot(anom_sst)
#sal
ncpath <- "~/Documents/Classes/course_lectures/ViaX/project/"
ncname <- "GFDL_8.5_SAL"
ncfname <- paste(ncpath, ncname, ".nc", sep="")
ncin <- nc_open(ncfname)
print(ncin)
names(ncin$var)

anom_sal <- stack(ncfname, varname="anomaly")
plot(anom_sal)

####present
#sst
sst_hist_hires <- raster("~/Documents/Classes/course_lectures/ViaX/project/water_temp_0000m_cumulative_mean.img")
plot(sst_hist_hires)
sst_hist_hires
anom_sst_hires <- disaggregate(anom_sst, fact=12.5) #get to same resolution as hist (1/.08)
anom_sst_hires <- projectRaster(anom_sst_hires,sst_hist_hires,method = 'bilinear')
plot(anom_sst_hires)
sst_fut <- sst_hist_hires + anom_sst_hires
plot(sst_fut)
plot(sst_hist_hires)

#sal
sal_hist_hires <- raster("~/Documents/Classes/course_lectures/ViaX/project/salinity_0000m_cumulative_mean.img")
plot(sal_hist_hires)
sal_hist_hires
anom_sal_hires <- disaggregate(anom_sal, fact=12.5) #get to same resolution as hist (1/.08)
anom_sal_hires <- projectRaster(anom_sal_hires,sal_hist_hires,method = 'bilinear')
plot(anom_sal_hires)
sal_fut <- sal_hist_hires + anom_sal_hires
plot(sal_fut)
plot(sal_hist_hires)
```





```{r}
# specify design
S     <- 151     # no. species
nsite <-     # no. time series
ntime <- 
obsEffort <- 1 # full census



termB <- FALSE    # include immigration/emigration term XB
termR <- TRUE     # include DI population growth term VL
termA <- TRUE     # include DD spp interaction term UA

predPrey <- predPrey[1:2]
colnames(predPrey) <- c("V1", "V2")
zeroAlpha <- no_effect
colnames(zeroAlpha) <- c("V1", "V2")
library(DiagrammeR)
foodWebDiagram(S, predPrey = predPrey, label = NULL, PLOT = TRUE, layout = 'rr')

```
Spp: 
      SVSPP		A standard code which represents a species caught in a trawl oe dredge.
    SCINAME		Scientific name of specimen.
    
    COMNAME		Accepted common name of a fish or invertebrate species.
    
    PYSPP		Prey species name.
    
    PYAPPR		Prey abbreviation.
diet_prey: 
	SVSPP: species caught (predator) 
	PYNAM		Prey scientific name.
PYSPP	VARCHAR2	Prey species name.

#A food web with movement in a noisy environment

Building on the same model, I now introduce environmental effects through movement. Here is a simulation for `Q = 3` predictors on movement, DI growth, and DD:

```{r, eval = F}
Q     <- 3     # no. predictors
termB <- T    # include immigration/emigration term XB
termR <- T    # include DI population growth term VL
termA <- T    # include DD spp interaction term UA

set.seed( seed )
tmp <- gjamSimTime(S, Q = Q, nsite, ntime, termB, termR, termA, 
                   obsEffort = obsEffort, predPrey, 
                   zeroAlpha, PLOT = T)
xdata  <- tmp$xdata
ydata  <- tmp$ydata
edata  <- tmp$edata
groups <- tmp$groups
times  <- tmp$times
#wstar  <- tmp$wstar
trueB <- tmp$trueValues
formula <- tmp$formula

legend('topright', snames, text.col = colF(S), ncol = 2, bty='n')

timeCol   <- 'times'
groupCol  <- 'groups'
groupVars <- c( 'groups' )
tmp <- gjamFillMissingTimes(xdata, ydata, edata, groupCol, timeCol,
                            FILLMEANS = T, groupVars = groupVars,
                            typeNames = 'DA', missingEffort = .1)    
xdata <- tmp$xdata
ydata <- tmp$ydata
edata <- tmp$edata
tlist <- tmp$timeList
#snames <- colnames(ydata)

#wTrue <- ydata/edata       # fill for trueValues
#wTrue[ rownames(trueB$w),] <- trueB$w

effort <- list(columns = 1:S, values = edata)

```


The prior parameter distribution includes some different, but still wide bounds on parameters for `beta`.  I have not changed `alphaSign`.


```{r, eval = F}
betaPrior <- list(lo = list(intercept = -Inf, x2 = -Inf, x3 = -Inf), 
                  hi = list(intercept = Inf, x2 = Inf, x3 = Inf) )

rhoPrior <- list(lo = list(intercept = 0), hi = list(intercept = .3) )
formulaRho <- as.formula(~ 1)

if(!termR) rhoPrior <- NULL
  
priorList <- list( formulaBeta = formula, formulaRho = formulaRho,
                   betaPrior = betaPrior, rhoPrior = rhoPrior, alphaSign = alphaSign)

tmp <- gjamTimePrior( xdata, ydata, edata, priorList)

timeList <- mergeList(tlist, tmp)
```

Here is model fitting:

```{r, eval = F}

modelList <- list(typeNames = 'DA', ng = 10000, burnin = 5000,  
                  timeList = timeList, effort = effort) 
outputXRA   <- gjam(formula, xdata=xdata, ydata=ydata, modelList=modelList)
```

Here are plots:

```{r, eval = F}
plotPars <- list(PLOTALLY=T, trueValues = trueB, SAVEPLOTS = T,
                 outFolder = 'gjamOutputXRA')
gjamPlot(outputXRA, plotPars)
save(outputXRA, file='gjamOutputXRA/output.rdata')
```

```{r xraTrueVsPars, echo=F, out.width = "45%", fig.cap = "Parameter recovery for the model is not terrible, because the effect of movement in this example is small."}
knitr::include_graphics("gjamOutputXRA/trueVsPars.pdf")
```


```{r xraYpred, echo=F, out.width = "55%", fig.cap = "Data prediction is still good due to model size."}
knitr::include_graphics("gjamOutputXRA/yPredBySpec_1.pdf")
```


```{r xraChains, echo=F, out.width = "45%", fig.cap = "Eigenvalues of alpha all have negative real parts."}
knitr::include_graphics("gjamOutputXRA/alphaEigenValues.pdf")
```



##Unknown environmental effects on movement

What are the effects of fitting a model where knowledge of the environment and food web are incomplete?  Here I fit the model to the previous data, but without knowledge of movement.  First I specify a prior distribution that omits `betaPrior`, because I don't know that it is operating here.  I then fit the model:

```{r, eval = F}

priorList <- list( formulaRho = formulaRho, rhoPrior = rhoPrior, alphaSign = alphaSign)
                   
tmp <- gjamTimePrior( xdata, ydata, edata, priorList )

timeB1 <- append( tlist, tmp )

modelList <- list(typeNames = 'DA', ng = 10000, burnin = 5000,  
                  timeList = timeB1, effort = effort) 

outputB1 <- gjam(formula = as.formula(~ 1), xdata=xdata, ydata=ydata, 
                  modelList=modelList, verbose = TRUE)
```

In the plots that follow there is no `beta` in the true values, because I have not fitted movement:

```{r, eval = F}
trueB1 <- trueB[ !names(trueB) == 'beta' ]
plotPars <- list(PLOTALLY=T, trueValues = trueB1, SAVEPLOTS = T, outFolder = 'gjamOutputB1')
gjamPlot(outputB1, plotPars)
save(outputB1, file='gjamOutputB1/output.rdata')
```



```{r b1TrueVsPars, echo=F, out.width = "45%", fig.cap = "Parameter recovery for the model."}
knitr::include_graphics("gjamOutputB1/trueVsPars.pdf")
```


```{r b1Ypred, echo=F, out.width = "55%", fig.cap = "Data prediction."}
knitr::include_graphics("gjamOutputB1/yPredBySpec_1.pdf")
```


```{r b1Chains, echo=F, out.width = "45%", fig.cap = "Eigenvalues of alpha all have negative real parts."}
knitr::include_graphics("gjamOutputB1/alphaEigenValues.pdf")
```






##A subset of the community

Four species are fitted to the six-species community.  In other words, two species are unobserved.  Here I am using the simulated community fitted previously, but fitting the model to only four species.  This means that the effects of two competitors (S5, S6) of (S3, S4) are omitted from the model.  I have included movement effects through beta in this example.

```{r, eval = F}

y4 <- ydata[,1:4]
e4 <- list(columns = 1:4, values = edata[,1:4])
betaPrior <- list(lo = list(intercept = -2, x2 = -100, x3 = -100), 
                  hi = list(intercept = 2, x2 = 100, x3 = 100) )
  
priorList <- list( formulaBeta = formula, formulaRho = formulaRho,
                   betaPrior = betaPrior, rhoPrior = rhoPrior, alphaSign = alphaSign[1:4,1:4])
                   
tmp <- gjamTimePrior( xdata, ydata = y4, edata = edata[,1:4], priorList)

timeC <- append( tlist, tmp )

modelList <- list(typeNames = 'DA', ng = 10000, burnin = 5000,  
           timeList = timeC, effort = e4) 

outputC <- gjam(formula, xdata = xdata, ydata = y4, modelList = modelList, verbose = TRUE)

trueC <- list(beta = trueB$beta[,1:4], rho = trueB$rho[1:4,1:4], 
           alpha = trueB$alpha[1:4,1:4], sigma = trueB$sigma[1:4,1:4],
           w = trueB$w[,1:4])

plotPars <- list(PLOTALLY=T, trueValues = trueC, SAVEPLOTS = T, outFolder = 'gjamOutputC' )
gjamPlot(outputC, plotPars)
save(outputC, trueC, e4, y4, file = 'gjamOutputC/output.rdata')
```

Effects here are modest, so the deterioration in the fit is not large:

```{r cTrueVsPars, echo=F, out.width = "45%", fig.cap = "Parameter recovery for the model where two species are omitted."}
knitr::include_graphics("gjamOutputC/trueVsPars.pdf")
```

The model still has enough parameters to predict the data:

```{r cYpred, echo=F, out.width = "55%", fig.cap = "Data prediction."}
knitr::include_graphics("gjamOutputC/yPredBySpec_1.pdf")
```







##Small sample size

Thus far, the sample has been in the thousands of counts.  In many data sets only a few individuals are observed.  This situation is simulated by using low `obsEffort`, i.e., only a small part of the population is observed.


```{r, eval = F}

obsEffort <- .01 # a small fraction observed

termB <- T    # include immigration/emigration term XB
termR <- T    # include DI population growth term VL
termA <- T    # include DD spp interaction term UA

set.seed( seed )
tmp <- gjamSimTime(S, Q = 3, nsite, ntime, termB, termR, termA, obsEffort = obsEffort, predPrey, 
                   zeroAlpha, PLOT = T)
xdata  <- tmp$xdata
ydata  <- tmp$ydata
edata  <- tmp$edata
groups <- tmp$groups
times  <- tmp$times
#wstar  <- tmp$wstar
trueE <- tmp$trueValues
formula <- tmp$formula

tmp <- gjamFillMissingTimes(xdata, ydata, edata, groupCol, timeCol,
                            FILLMEANS = T, groupVars = groupVars,
                            typeNames = 'DA', missingEffort = .1)    
xdata <- tmp$xdata
ydata <- tmp$ydata
edata <- tmp$edata
tlist <- tmp$timeList
#snames   <- colnames(ydata)

# fill for trueValues
#wTrue <- ydata/edata
#wTrue[ rownames(trueE$w),] <- trueE$w

effort <- list(columns = 1:S, values = edata)

```

Here is the prior parameter distribution specified previously:

```{r, eval = F}
  
priorList <- list( formulaBeta = formula, formulaRho = formulaRho,
                   betaPrior = betaPrior, rhoPrior = rhoPrior, alphaSign = alphaSign)
                   
tmp <- gjamTimePrior( xdata, ydata, edata, priorList)
timeList <- mergeList(tlist, tmp)

```

Here are model fitting and plots:

```{r, eval = F}

modelList <- list(typeNames = 'DA', ng = 10000, burnin = 5000,  
           timeList = timeList, effort = effort) 

outputE <- gjam(formula, xdata=xdata, ydata=ydata, modelList=modelList, verbose = TRUE)
```

Here are plots:

```{r, eval = F}

plotPars <- list(PLOTALLY=T, trueValues = trueE, SAVEPLOTS = T, outFolder = 'gjamOutputE' )
gjamPlot(outputE, plotPars)
save(outputE, trueE, file='gjamOutputE/output.rdata')
```

Effects on parameter recovery are large.  Note that the size of the sample is the same as before, all I have done is reduce observation effort:

```{r eTrueVsPars, echo=F, out.width = "45%", fig.cap = "Parameter recovery deteriorated by small sample size."}
knitr::include_graphics("gjamOutputE/trueVsPars.pdf")
```

Data prediction is ok for abundant species, but not for rare species.  There are too many zeros:

```{r eYpred, echo=F, out.width = "55%", fig.cap = "Data prediction is especially poor for rare species."}
knitr::include_graphics("gjamOutputE/yPredBySpec_1.pdf")
```





##Combined effects

What if we fit the model without allowing for the environmental effects on movement and we have knowledge of only some of the interacting species.  In this example I omit the movement term, species S5 and S6, and I have a limited sample.  In other words, I combine effects examined individually in previous examples.


```{r, eval = F}
  
priorList <- list( formulaRho = formulaRho, rhoPrior = rhoPrior, alphaSign = alphaSign[1:4,1:4])
                   
tmp <- gjamTimePrior( xdata, ydata[,1:4], edata[,1:4], priorList)

timeList <- mergeList(timeList, tmp)
```

Here are model fitting and plots

```{r, eval = F}

modelList <- list(typeNames = 'DA', ng = 10000, burnin = 5000,  
           timeList = timeList, effort = e4) 

outputF <- gjam(formulaRho, xdata=xdata, ydata=ydata[,1:4], modelList=modelList, verbose = TRUE)
```


```{r, eval = F}
trueF <- trueC[!names(trueC) == 'beta']
plotPars <- list(PLOTALLY=T, trueValues = trueF, SAVEPLOTS = T, outFolder = 'gjamOutputF' )
gjamPlot(outputF, plotPars)
save(outputF, trueF, file='gjamOutputF/output.rdata')

```


Data prediction is still ok for abundant species, but not for rare species:

```{r fYpred, echo=F, out.width = "55%", fig.cap = "Data prediction is especially poor for rare species."}
knitr::include_graphics("gjamOutputF/yPredBySpec_1.pdf")
```

However, the parameter estimates give an inaccurate representation of the contributions to population growth.

```{r fTrueVsPars, echo=F, out.width = "45%", fig.cap = "Parameter recovery deteriorated by the combined effects of missing movement, missing species, and small sample size."}
knitr::include_graphics("gjamOutputF/trueVsPars.pdf")
```


##A static model

--relationship between sigma and alpha when fitting static jsdm
- similarities in sign of beta?


```{r, eval = F}

estat <- effort
estat$values <- estat$values[-timeZero,]
modelList <- list(typeNames = 'DA', ng = 2000, burnin = 1000, effort = estat) #, reductList = reductList)

xstat <- xdata[-timeZero,]
ystat <- ydata[-timeZero,]
outputS <- gjam(formula, xdata = xstat, ydata = ystat,
                 modelList = modelList, verbose = TRUE)

plotPars <- list(PLOTALLY=T )
gjamPlot(outputS, plotPars)
```







##BBS data

################ skip this

```{r, echo=FALSE, eval = F}
#setwd("~/Documents/Manuscripts/gjamTime")
load('bbsExample.Rdata')

```

This is a bit of the BBS data, `xdata`:

```{r, echo=FALSE, results='asis', eval=F}
knitr::kable(head(xdata), digits=4)
```

The counts in `ydata` have S columns.  I trim it down here:

```{r, echo=FALSE, eval=F}
ydata <- gjamTrimY(ydata,1800, OTHER = FALSE)$y
knitr::kable(head(ydata[1:17,1:4]), digits=3)
```

Time series data need at least a `times` variable, indicating sequence.  If there are multiple sequences, they also need a `groups` variable.  These are the names of columns in `xdata`.  Here are observations by `year` and `Route`:

```{r timeGroup, echo=FALSE, eval=F}
timeCol  <- 'year'
groupCol <- 'Route'
knitr::kable(table(xdata[,c(timeCol,groupCol)])[,1:15], digits=2)
```

Zeros in this table indicate routes that were not sampled in a given year. There are many missing values.


```{r fill, echo=FALSE, eval=F}

groupVars <- c( "lon","lat","Route","soil","nlcd" )
xdata <- xdata[,c( groupVars, 'year', 'temp', 'StartWind', 'StartSky')]

missingEffort <- .1

edata <- ydata*0 + 100
tmp <- gjamFillMissingTimes(xdata, ydata, edata, groupCol, timeCol,
                            groupVars = groupVars, FILLMEANS = T,
                            typeNames = 'DA', missingEffort = missingEffort)    
xdata    <- tmp$xdata
ydata    <- tmp$ydata
timeList <- tmp$timeList
edata    <- tmp$edata
snames   <- colnames(ydata)


```

I would now replace the missing observations in `xdata` with known values for those locations and years.  I leave the `NA`s in `ydatSS` so they will be fitted. Missing values in `xdata` will also be fitted.  Recall that high levels of missingness will destroy the fit.


```{r more, echo=FALSE, eval=F}

tpath <- "/Users/jimclark/makeMastOnJimClark/makeMast/climateBuild/terraClimateFiles"
cf    <- "/Users/jimclark/makeMastOnJimClark/makeMast/climateBuild/climateFunctions.r"
source(cf)

sites  <- sort(unique(xdata$groups))
mm     <- match( sites, xdata$groups )
lonLat <- xdata[mm,c('lon','lat')]
rownames(lonLat) <- sites

uvars <- c("tmin","tmax","ppt")

years <- c(min(xdata$year, na.rm=T):max(xdata$year, na.rm=T))

tmp <- getTileTerraClimate(lonLat, years, 
                           months = 1:12, vars = uvars, 
                           DOWNSCALE = T, path = tpath)
tmpt <- tmp$tallFormat                  
tmpw <- tmp$wideFormat
tempVec <- as.matrix( (tmpw$tmin[,-c(1:2)] + tmpw$tmax[,-c(1:2)])/2 )
precVec <- as.matrix( tmpw$ppt[,-c(1:2)] )
tminVec <- as.matrix( tmpw$tmin[,-c(1:2)] )

cc <- columnSplit(colnames(tempVec),'_')
yi <- as.numeric(cc[,1])
mi <- as.numeric(cc[,2])

# annual precip
ii <- rep(rownames(precVec), ncol(precVec))
jj <- rep(yi, each = nrow(precVec))

prec <- tapply( precVec, list(site = ii, year = jj), sum)
precAnom <- sweep( prec, 1, rowMeans(prec), '-' )
precSite <- matrix( rowMeans(prec), nrow(prec), ncol(prec))

ii <- match( xdata$groups, rownames(prec))
jj <- match( as.character(xdata$year), colnames(prec) )

xdata$precSite <- signif( precSite[ cbind(ii, jj) ], 3)
xdata$precAnom <- signif( precAnom[ cbind(ii, jj) ], 3)

# summer deficit
pet <- monthlyPET(yi, mi, tempVec, precVec, lat=tmpw$ppt[,'lat'])[[1]]  #FIX LAT 
rownames(pet) <- rownames(tempVec)
colnames(pet) <- colnames(tempVec)
def <- pet - precVec
rownames(def) <- rownames(precVec)

ws <- which(mi %in% 6:8)
ds <- def[,ws]
ii <- rep(rownames(ds), ncol(ds))
jj <- rep(yi[ws], each = nrow(ds))
def <- tapply( ds, list(site = ii, year = jj), sum)

defAnom <- sweep( def, 1, rowMeans(def), '-' )
defSite <- matrix( rowMeans(def), nrow(def), ncol(def))

ii <- match( xdata$groups, rownames(defAnom))
jj <- match( as.character(xdata$year), colnames(defAnom) )
xdata$defSite <- signif( defSite[ cbind(ii, jj) ], 3)
xdata$defAnom <- signif( defAnom[ cbind(ii, jj) ], 3)

#winterTmin
ws <- which(mi %in% c(12, 1, 2) )
ds <- tempVec[,ws]

ii <- rep(rownames(ds), ncol(ds))
jj <- rep(yi[ws], each = nrow(ds))

winterTmin <- tapply( ds, list(site = ii, year = jj), min)

ii <- match( xdata$groups, rownames(winterTmin))
jj <- match( as.character(xdata$year), colnames(winterTmin) )

xdata$winterTmin <- signif( winterTmin[ cbind(ii, jj) ], 3)
colnames(tmpt)[1] <- 'plot'

#temp at observation month

ws <- which(mi == 6 )
ds <- tempVec[,ws]
ii <- rep(rownames(ds), ncol(ds))
jj <- rep(yi[ws], each = nrow(ds))

juneTemp <- tapply( ds, list(site = ii, year = jj), min)

ii <- match( xdata$groups, rownames(juneTemp))
jj <- match( as.character(xdata$year), colnames(juneTemp) )

xdata$juneTemp <- signif( juneTemp[ cbind(ii, jj) ], 3)

nlcd <- as.character(xdata$nlcd)
nlcd[ nlcd == 'water' ] <- 'wetland'
nlcd[ nlcd == 'forest-decid' ] <- 'forest'
nlcd[ nlcd == 'forest-mixed' ] <- 'forest'
nlcd[ nlcd == 'forest-evergreen' ] <- 'forest'
nlcd[ nlcd == 'cultivated-pasture' ] <- 'herb-grassland'
xdata$nlcd <- as.factor(nlcd)

ydata <- ydata[,!colnames(ydata) == 'other']
edata <- edata[,!colnames(edata) == 'other']

save( xdata, ydata, missingEffort, timeList, edata, file = 'BBSexampleTime.rdata')

```

###################


Start here:

```{r, eval = F}

setwd("~/Documents/Manuscripts/gjamTime")
load('BBSexampleTime.rdata')
library(maps)

#def <- xdata$defSite
#def <- (def - mean(def, na.rm=T))/sd(def, na.rm=T)

#df <- seq(-3, 3, length=20)


colT <- colorRampPalette( c('#8c510a','#d8b365','#c7eae5','#5ab4ac','#01665e','#2166ac') )
#colT <- colorRampPalette( c('#8c510a','#d8b365','#01665e','#2166ac') )

cols <- rev( colT(20) )

#di <- findInterval(def, df, all.inside = T)

spec <- 'ChimneySwift'

spec <- 'MourningDove'

spec <- 'IndigoBunting'

spec <- 'BrownThrasher'

spec <- 'EasternTowhee'

spec <- 'WoodThrush'

spec <- 'EuropeanStarling'


y    <- ydata[,spec]

# route mean
cy   <- tapply(y, xdata$Route, mean, na.rm=T)
wi   <- match( as.numeric(names(cy)), xdata$Route )
ll   <- xdata[ wi, c('lon','lat') ]

# the moisture deficit varies by route
def <- xdata$defSite[wi]

# discretize color scheme
df   <- seq(min(def), max(def), length=20)

cols <- rev( colT(20) )

# assign a color to each anomaly
di <- findInterval(def, df, all.inside = T)

map('county', xlim = c(-85, -75), ylim = c(33.6, 36.8), col='grey')
map('state', xlim = c(-85, -75), ylim = c(33.6, 36.8), add=T)
cex <- 5*cy/max(cy, na.rm=T)
points(ll[,1], ll[,2], pch = 16, cex = cex, col = cols[di] )
title(spec)

```

```{r, eval = F}

xdata$StartWind <- as.factor(xdata$StartWind)
xdata$StartSky  <- as.factor(xdata$StartSky)
S <- ncol(ydata)
snames <- colnames(ydata)

guild1 <- c("AmericanRobin", "EuropeanStarling", "AmericanCrow", "CommonGrackle")
guild2 <- c("NorthernCardinal", "ChippingSparrow", "CommonGrackle", "AmericanCrow")
guild3 <- c("NorthernCardinal", "ChippingSparrow", "BlueJay", "BrownThrasher",
            "EasternTowhee", "WoodThrush", "MourningDove", "CarolinaWren")
guild4 <- c("EasternWood-Pewee", "Red-eyedVireo", "IndigoBunting",
            "TuftedTitmouse","Red-eyedVireo","CarolinaChickadee")

guildList <- list(guild1 = match(guild1, snames), 
                  guild2 = match(guild2, snames), 
                  guild3 = match(guild3, snames), 
                  guild4 = match(guild4, snames)) # competition groups

foodWebDiagram(S, guildList, label = snames, intraComp = 1:S)

fromTo <- foodWebDiagram(S, guildList, PLOT = F)


formula    <- as.formula(~ StartWind + defSite + nlcd)
formulaRho <- as.formula(~ defSite + nlcd)

hi <- c(intercept = Inf, StartWind2 = 0, StartWind3 = 0, StartWind4 = 0,  
        defSite = Inf)
lo <- list(intercept = -Inf, defSite = -Inf,
           StartWind0 = 0, StartWind2 = -1, StartWind3 = -2, StartWind4 = -3) 
betaPrior <- list(lo = lo, hi = hi)

lform <- as.formula(~ defSite + nlcd)

lo <- list(intercept = -.05)                                # winter temp
hi <- list(intercept = .1) 
rhoPrior <- list(lo = lo, hi = hi)

alphaSign  <- matrix(0, S, S)
colnames(alphaSign) <- rownames(alphaSign) <- snames
alphaSign[ fromTo ] <- -1


priorList <- list( formulaBeta = formula, formulaRho = formulaRho,
                   betaPrior = betaPrior,
                   rhoPrior = rhoPrior, alphaSign = alphaSign)
                   
tmp <- gjamTimePrior( xdata, ydata, edata, priorList)

wf <- which( startsWith( rownames(tmp$betaPrior$lo), 'nlcd' ) )
tmp$betaPrior$lo[wf,] <- NA
tmp$betaPrior$hi[wf,] <- NA

tmp$betaPrior$lo['defSite',] <- tmp$betaPrior$hi['defSite',] <- NA

timeList <- mergeList(timeList, tmp)

```

I do not need to specify a prior for $\boldsymbol{\Lambda}$, because it will inherit the prior for $\mathbf{B}$, albeit reorganized as an environment by species interaction matrix.

The prior for $\mathbf{A}$ is $S \times S$, with values given by the interaction matrix.  Here is an example emphasizing competition:


Here are model fitting and plots

```{r, eval = F}

effort <- list(columns = 1:S, values = edata)

rl <- list(N = 8, r = 5)
modelList <- list( typeNames = 'DA', ng = 8000, burnin=4000, # reductList = rl, 
           timeList=timeList, effort = effort)

outputBBS <- gjam(formula, xdata=xdata, ydata=ydata, modelList=modelList, verbose = T)

specColor <- rep( '#000000' ,S) # black
names(specColor) <- snames
sc <- colF( length(guildList) )
for(j in 1:length(guildList)){
  specColor[ snames[ guildList[[j]] ] ] <- sc[j]
}

#palette('default')

save(outputBBS, specColor, file='gjamOutputBBS/outputBBS.rdata')

plotPars <- list(specColor = specColor, GRIDPLOTS=T, PLOTALLY=T, SAVEPLOTS = T,
                 outFolder = 'gjamOutputBBS')
gjamPlot(outputBBS, plotPars)

library(xtable)

out <- outputBBS$parameters
tnames <- c('betaStandXTable', 'rhoStandXTable', 'alphaTable')

for(k in 1:length(tnames)){
  
  xk <- out[tnames[k]][[1]]
  
  prior <- columnPaste(as.character(signif(xk[,'priorLo'], 3)), 
                       as.character(signif(xk[,'priorHi'], 3)), ', ')
  prior <- paste('(', prior, ')', sep='')
  prior <- .replaceString(prior, ',', ', ')
  xk <- xk[,!colnames(xk) %in% c('priorLo','priorHi')]
  
    post <- columnPaste(as.character(signif(xk[,'CI_025'], 4)), 
                       as.character(signif(xk[,'CI_975'], 4)), ', ')
  post <- paste('(', post, ')', sep='')
  post <- .replaceString(post, ',', ', ')
  xk <- xk[,!colnames(xk) %in% c('priorLo','priorHi','CI_025','CI_975')]
  
  print('')
  print(tnames[k])
  xp <- data.frame(xk, post, prior, stringsAsFactors = F)
  ww <- which(sapply(xp, is.complex))
  if(length(ww) > 0)for(w in ww)xp[[w]] <- as.character(xp[[w]])
  
  xp <- xtable( xp, digits = 4 )
  rownames(xp) <- NULL
  print( xp, hline.after=c(-1, 0), tabular.environment = "longtable",
         floating = F, include.rownames=FALSE)
}

burnin <- outputBBS$modelList$burnin
ng     <- outputBBS$modelList$ng

alphaGibbs <- outputBBS$chains$alphaGibbs
alphaTable <- outputBBS$parameters$alphaTable

np <- sqrt(nrow(alphaTable))
nrow <- ncol <- round(np)
if(nrow^2 > nrow(alphaTable))nrow <- nrow + 1

#par(mfrow = c(nrow,ncol), mar = c(1,1,.1, .1), bty = 'n', oma = c(2,2,1,1) )

location <-  columnSplit(alphaTable[,'alpha_{to, from}'], ',') 

snames <- colnames(outputBBS$prediction$ypredMu)
S  <- length(snames)
ss <- matrix( match(location, snames ), ncol=2)

layoutMatrix <- matrix(0, nrow = S, ncol = S)
layoutMatrix[ ss ] <- c(1:nrow(ss))


par(new = F)
layout( layoutMatrix )
par(mar = c(.1,.1,.1, .1), bty = 'n', oma = c(5,5,1,1), xpd = F )
#library(LaplacesDemon)

for(i in 1:ncol(alphaGibbs)){

  
  pii <- unlist( alphaTable[i,c('priorLo','priorHi')] )
  
  cx <- alphaGibbs[burnin:ng,i]
  cy <- runif(ng - burnin + 1, pii[1], pii[2])
  xi <- density(cx)
  x <- xi$x
  y <- xi$y
  wi <- which(x >= pii[1] & x <= pii[2])
  x <- x[wi]
  y <- y[wi]
  x <- c(x[1], x, x[length(x)])
  y <- c(0, y, 0)
  plot(x, y, type = 'l', xlab = '', ylab = '', xaxt = 'n', yaxt = 'n')
  polygon(x, y, xlab = '', ylab = '', xaxt = 'n', yaxt = 'n', col = 'grey')
  
 # zi <- density(cy)
 # kl <- KLD(xi$y, zi$y)#$mean.sum.KLD 
 # kld <- signif( kl$mean.sum.KLD, 2)
 # text(mean(x), mean(y), kld)
}

#mtext(snames, side = 2, at = S:1, cex=.7, outer  = TRUE)
mtext('Parameter value', 1, line=1, outer  = TRUE)
mtext('Density', 2, line=1, outer  = TRUE)


lgibbs <- outputBBS$chains$lgibbs
rhoTable <- outputBBS$parameters$rhoStandXTable


location <-  columnSplit(rhoTable[,'rho_{to, from}'], ',') 
xn <- unique(location[,2])

s1 <- match(location[,1], snames )
s2 <- match(location[,2], xn )

layoutMatrix <- matrix(0, nrow = S, ncol = length(xn))
layoutMatrix[ cbind(s1, s2) ] <- c(1:nrow(location))


par(new = F)
layout( layoutMatrix )
par(mar = c(.1,.1,.1, .1), bty = 'n', oma = c(5,5,1,1), xpd = F )

for(i in 1:ncol(lgibbs)){
  
  pii <- unlist( rhoTable[i,c('priorLo','priorHi')] )
  
  xi <- density(lgibbs[burnin:ng,i])
  x <- xi$x
  y <- xi$y
  wi <- which(x >= pii[1] & x <= pii[2])
  x <- x[wi]
  y <- y[wi]
  x <- c(x[1], x, x[length(x)])
  y <- c(0, y, 0)
  plot(x, y, type = 'l', xlab = '', ylab = '', xaxt = 'n', yaxt = 'n')
  polygon(x, y, xlab = '', ylab = '', xaxt = 'n', yaxt = 'n', col = 'grey')
}
mtext('Parameter value', 1, line=1, outer  = TRUE)
mtext('Density', 2, line=1, outer  = TRUE)

```

Equilibrium abundance:

```{r, eval = F}
wstar <- .wrapperEquilAbund(outputBBS, nsim = 1000, ngrid = 9, BYFACTOR = T, 
                            verbose = T)

save(outputBBS, specColor, wstar, file='gjamOutputBBS/outputBBS.rdata')

notOther <- outputBBS$inputs$notOther
ccMu <- wstar$ccMu[,notOther]
ccSd <- wstar$ccSd[,notOther]
ccx  <- wstar$x
#    ccx  <- ccx[, !colnames(ccx) %in% attributes(ccx)$factors, drop=F]
#    ccx  <- ccx[,-1, drop=F]


cols <- colorRampPalette( c('#a6611a','#dfc27d','#f5f5f5','#80cdc1','#018571') )


cols <- colorRampPalette( c('#a6611a','#dfc27d','#80cdc1','#018571') )

nlcd <- colnames(ccx)[ which(startsWith(colnames(ccx), 'nlcd')) ]
f1   <- rownames(outputBBS$inputs$factorBeta$contrast$nlcd)[1]

coverType <- cbind(.5, ccx[,nlcd])
colnames(coverType)[1] <- f1
nlcd <- c(f1, nlcd)

coverType <- nlcd[ apply(coverType, 1, which.max) ]
coverType <- .replaceString(coverType, 'nlcd','')


SAVEPLOTS <- T
outFolder <- 'gjamOutputBBS'

types <- c( "dev",  "cultivatedcrop", "herbgrassland","shrubscrub",
           "forest", "wetland")

np <- ncol(ccMu)

npage <- 1
o   <- 1:np
if(np > 16){
  npage <- ceiling(np/16)
  np    <- 16
}

SO <- length(notOther)

mfrow <- getPlotLayout(np)

k   <- 0
add <- F
o   <- 1:np
o   <- o[o <= 16]

xm <- 'deficit'

for(p in 1:npage){
  
  file <- paste('equilAbund_', xm, '_', p,'.pdf',sep='')
  
  if(SAVEPLOTS)pdf( file=.outFile(outFolder,file) )
  
  npp <- ncol(ccMu) - k
  if(npp > np)npp <- np 
  mfrow <- getPlotLayout(np)
  par(mfrow=mfrow, bty='n', omi=c(.5,.5,0,0), mar=c(1,2,2,1))
  pj <- 1
  
  for(j in o){
    
    yy  <- ccMu[,j]
    
    ct  <- tapply(yy, list(defSite = round(ccx[,'defSite'], 1), nlcd = coverType), mean)
    cl  <- tapply(yy, list(defSite = round(ccx[,'defSite'], 1), nlcd = coverType), 
                  quantile, pnorm(-1))
    ch  <- tapply(yy, list(defSite = round(ccx[,'defSite'], 1), nlcd = coverType), 
                  quantile, pnorm(1))
    
    def <- as.numeric(rownames(ct))
    nk <- length(def)
    
    cdd  <- rev( cols(nk) )
    
    ylimit <- c(0, 1.5*max(ct))
    
 #   ord <- order( colMeans(ct) )
    
    ct <- ct[,types]
    cl <- cl[,types]
    ch <- ch[,types]
    
    tbar <- barplot( ct, beside = T, plot = F) 
    
    plot(NA, xlim = range(tbar), ylim = range( cbind(cl, ch) ),
         xaxt = 'n', xlab = '', ylab = '')
    axis(1, at = c(tbar[1,], tbar[nrow(tbar),]), labels = F)
    for(k in 1:ncol(ct)){
      .shadeInterval(tbar[,k], loHi = cbind(cl[,k],ch[,k]) )
 #     lines(tbar[,k], ct[,k], lwd=2)
      
      cc <- 1:(nk-1)
      segments(tbar[cc,k], ct[cc,k], tbar[cc+1,k], ct[cc+1,k], col = cdd[-1], lwd=2)
      segments(tbar[1:nk,k], cl[1:nk,k], tbar[1:nk,k], ch[1:nk,k], col = cdd, lwd=1)
      segments(tbar[cc,k], cl[cc,k], tbar[cc+1,k], cl[cc+1,k], col = cdd[-1], lwd=.5)
      segments(tbar[cc,k], ch[cc,k], tbar[cc+1,k], ch[cc+1,k], col = cdd, lwd=.5)
    }
    
    
    
 #   tbar <- barplot( ct, beside = T, col = cdd, border = cdd, 
 #                    ylim = ylimit, xaxt = 'n') 
    xbar <- colMeans(tbar)
    ybar <- apply(ct, 2, max)
    if(pj == 1)text(xbar, ybar, colnames(ct), srt = 80, pos = 4)
    
    k <- k + 1
    if(k > 26)k <- 1
    pj <- pj + 1
    
    lab <- colnames(ccMu)[j]
    
    .plotLabel( lab,above=T )
  }
  mtext('Moisture deficit by land cover', 1, outer=T)
  mtext('Equilibrium abundance', 2, outer=T)
  
  o <- o + 16
  o <- o[o <= SO]
  
  if(!SAVEPLOTS){
    readline('equilibrium abundance -- return to continue ')
  } else {
    dev.off()
  }
}

save(outputBBS, wstar, specColor, file='gjamOutputBBS/outputBBS.rdata')


```


Ordinal data

```{r, eval = F}

modelList$typeNames <- 'OC'
modelList$effort <- NULL
ydataOrd  <- ydata
ydataOrd[ timeList$timeZero,] <- ydataOrd[ timeList$timeZero,]/missingEffort # restore original count
ydataOrd  <- ceiling( ydata/10 )
ydataOrd[ydataOrd > 25] <- 25


modelList$ng <- 1000
modelList$burnin <- 500
  
outputBBSOrd <- gjam(formula, xdata=xdata, ydata=ydataOrd, modelList=modelList, verbose = T)

plotPars <- list(specColor = specColor, GRIDPLOTS=T, PLOTALLY=T, SAVEPLOTS = T,
                 outFolder = 'gjamOutputBBSord')
gjamPlot(outputBBSOrd, plotPars)


```

#Wisconsin lakes

"Potential planktivory was calculated as the biomass of fishes that could potentially consume zooplankton, based on species and body size. Only two fish samples were taken per year, at the beginning and end of summer
stratification. We log-linearly interpolated between these points to obtain estimates of potential planktivory at the times of plankton samples."

###########################skip

```{r, eval = F}

lakeData <- as.data.frame( read.table( 'lakeExample/lakeData.txt', header=T ) )
fishData <- as.data.frame( read.table( 'lakeExample/fishData.txt', header=T ) )

data <- cbind(lakeData, fishData)
data <- data[,!duplicated(colnames(data))]
data <- data[,!colnames(data) == 'dummy']

lake <- rep('  ', nrow(data))
lake[ data$lake == 1 ] <- 'EastLong'
lake[ data$lake == 2 ] <- 'WestLong'
lake[ data$lake == 3 ] <- 'Peter'
lake[ data$lake == 4 ] <- 'Paul'

data$lake <- lake
data$year <- data$year + 1900
data$group <- columnPaste(data$lake, data$year)

wseq <- seq(1, 365, by=7)
data$week <- findInterval(data$day, wseq)
wseq <- seq(1, 365, by=30)
data$month <- findInterval(data$day, wseq)

EastLong  <- c(46.235811, -89.499337)
WestLong  <- c(46.235811, -89.499337)
Peter <- c(46.252721, -89.503695)
Paul  <- c(46.251384, -89.503522)

lonLat <- rbind( EastLong, WestLong, Peter, Paul )
lonLat <- lonLat[,c(2,1)]
colnames(lonLat) <- c('lon','lat')

timeCol  <- 'week'
groupCol <- 'group'


groupVars <- c( "lake","group","year" )
xdata <- data[,c( groupVars, 'day', 'week', 'month', 'logBiomass', 'Pvol', 'Pvory')]
ydata <- data[,!colnames(data) %in% colnames(xdata)]

ydata$fishBiomass <- round( exp(xdata[,'logBiomass']) )

edata <- ydata*0 + 1
tmp <- gjamFillMissingTimes(xdata, ydata, edata, groupCol, timeCol,
                            groupVars = groupVars, FILLMEANS = T,
                            typeNames = 'DA', missingEffort = .1)    
xdata    <- tmp$xdata
ydata    <- tmp$ydata
timeList <- tmp$timeList
edata    <- tmp$edata
snames   <- colnames(ydata)

tz <- timeList$timeZero
xdata[tz,c('logBiomass','Pvol','Pvory')] <- xdata[tz+1,c('logBiomass','Pvol','Pvory')]

xdata$day[tz] <- xdata$day[tz+1] - 7

wseq <- seq(1, 365, by=30)
xdata$month <- findInterval(xdata$day, wseq)

years <- sort(unique(xdata$year))

# monthly temp and precip

tpath <- "/Users/jimclark/makeMastOnJimClark/makeMast/climateBuild/terraClimateFiles"
cf    <- "/Users/jimclark/makeMastOnJimClark/makeMast/climateBuild/climateFunctions.r"
source(cf)

uvars <- c("tmin","tmax","ppt")
tmp <- getTileTerraClimate(lonLat, years, 
                           months = 1:12, vars = uvars, 
                           DOWNSCALE = T, path = tpath)
tmpt <- tmp$tallFormat                  
tmpw <- tmp$wideFormat
tempVec <- as.matrix( (tmpw$tmin[,-c(1:2)] + tmpw$tmax[,-c(1:2)])/2 )
precVec <- as.matrix( tmpw$ppt[,-c(1:2)] )
tminVec <- as.matrix( tmpw$tmin[,-c(1:2)] )

cc <- columnSplit(colnames(tempVec),'_')
yi <- as.numeric(cc[,1])
mi <- as.numeric(cc[,2])

mo   <- as.character(xdata$month)
mo[ nchar(mo) == 1 ] <- paste('0',mo[ nchar(mo) == 1 ],sep='')
yrMo <- columnPaste(xdata$year,mo,'_')
ii   <- match(xdata$lake,rownames(tempVec))
jj   <- match(yrMo, colnames(tempVec))

xdata$temp <- round( tempVec[ cbind(ii, jj) ], 1)
xdata$prec <- round( precVec[ cbind(ii, jj) ], 1)

save( xdata, ydata, timeList, edata, file = 'lakeExample/lakeExampleTime.rdata')

```
###############

Start here:

```{r, eval = F}

setwd("~/Documents/Manuscripts/gjamTime")
load('lakeExample/lakeExampleTime.rdata')

xdata$lake <- as.factor(xdata$lake)
xdata$Pvory[ xdata$Pvory < 1 ] <- 0
xdata$Pvory <- as.factor(xdata$Pvory)
colnames(xdata)[colnames(xdata) == 'logBiomass'] <- 'bass'

ydata <- ydata[,colnames(ydata) != 'fishBiomass']
edata <- edata[,colnames(edata) != 'fishBiomass']

colnames(ydata) <- colnames(edata) <- c('sPhy','lPhy','lZoo','sZoo')
ydata <- ydata[,c('sPhy','lPhy','sZoo','lZoo')]
edata <- edata[,c('sPhy','lPhy','sZoo','lZoo')]



#xdata$planktivory <- xdata$logBiomass

snames <- colnames(ydata)
S <- length(snames)


specColor <- colF( S )
names(specColor) <- snames


predPrey  <- rbind( c(3, 1), c(4, 1), c(4, 2) )   # second is prey of first 
zeroAlpha <- rbind( c(2, 3),  
                    c(4, 3))
zeroAlpha <- rbind(zeroAlpha, zeroAlpha[,c(2,1)])
 
preyAll <-  rbind( predPrey, 
                   c( 1, 5), c( 2, 5),
                   c( 7, 3), c(7, 4),
                   c( 6, 7))
zeroAll <- rbind( zeroAlpha,
                  c(5, 3), c(5, 4), c(5, 5), c(5, 6),
                  c(3, 5), c(4, 5), c(3, 6), c(3, 7), c(4, 6),
                  c(4, 7),
                  c(6, 1), c(6, 2), c(6, 5), c(6, 6),
                  c(1, 6), c(2, 6),
                  c(6, 3), c(6, 4), 
                  c(1, 5), c(2, 5), c(5, 7),
                  c(7, 1), c(7, 2), c(7, 5), c(7, 6),
                  c(1, 7), c(2, 7), c(7, 7))

label <- c( colnames(ydata), 'Pvol','bass','perch')

foodWebDiagram(S = length(label), predPrey = preyAll, zeroAlpha = zeroAll, label = label, 
               layout = 'rr')

ytime <- numeric(0)
for(k in 1:length(snames)){
  sPhy <- tapply( ydata[,snames[k]], list(week = xdata$week),
                  quantile, pnorm(c(0, -1, 1, -1.96, 1.96)), na.rm=T) 
  
  sp <- matrix( unlist( sPhy ), ncol=5, byrow=T)
  sp[,1] <- tapply( ydata[,snames[k]], list(week = xdata$week),
                    mean, na.rm=T)
  rownames(sp) <- paste( snames[k], names(sPhy), sep='_')
  ytime <- rbind(ytime, sp)
}

week <- as.numeric(names(sPhy))

par(mfrow = c(5,1), bty='n', mar = c(1,1,1,1), omi=c(1,1,.1,.1))

for(j in 1:length(snames)){
  
  ci <- ytime[ grep(snames[j], rownames(ytime)),]
  
  
  .shadeInterval( week, loHi = ci[,4:5],col=specColor[j],PLOT=T,add=F,
                  xlab=' ',ylab=' ',   
                  LOG=F, trans = .3)
  .shadeInterval( week, loHi = ci[,2:3],col=specColor[j], PLOT=T, add=T, 
                  trans = .3)
  lines(week, ci[,1],  lty=2, lwd=2, col = specColor[j])
  
  .plotLabel( snames[j],above=F )
}

temp <- tapply( xdata$temp, list(week = xdata$week),
                quantile, pnorm(c(0, -1, 1, -1.96, 1.96)), na.rm=T) 
ci <- matrix( unlist( temp ), ncol=5, byrow=T)
ci[,1] <- tapply( xdata$temp, list(week = xdata$week),
                  mean, na.rm=T)
.shadeInterval( week, loHi = ci[,4:5],col='black',PLOT=T,add=F,
                xlab=' ',ylab=' ',   
                LOG=F, trans = .3)
.shadeInterval( week, loHi = ci[,2:3],col='black', PLOT=T, add=T, 
                trans = .3)
lines(week, ci[,1],  lty=2, lwd=2, col = 'black')

.plotLabel( 'Temperature' ,above=F )

mtext( 'Week', 1, outer=T, line=2)
mtext('Observed', 2, outer=T, line=2)
```


```{r}

formulaRho  <- as.formula( ~ Pvol + lake*bass + temp )

formulaRho  <- as.formula( ~ Pvol + bass*temp )

rhoPrior  <- list(lo = list(intercept = 0, Pvol = 0), 
                  hi = list(intercept = .5))

alphaSign  <- matrix(-1, S, S)
colnames(alphaSign) <- rownames(alphaSign) <- colnames(ydata)
alphaSign[ predPrey ] <- 1
alphaSign[ zeroAlpha ] <- 0
colnames(alphaSign) <- rownames(alphaSign) <- snames
  
priorList <- list( formulaRho = formulaRho,
                   rhoPrior = rhoPrior, alphaSign = alphaSign)
                   
tmp <- gjamTimePrior( xdata, ydata, edata, priorList )

# planktivores only consume daphnia, non-daphnia, others get NA

brows <- grep('bass', rownames(tmp$rhoPrior$lo))
tmp$rhoPrior$lo['bass','sZoo'] <- 0  # neg effect of small fish, pos effect on daphnia
tmp$rhoPrior$lo['bass','lZoo'] <- 0
tmp$rhoPrior$lo[brows,'sPhy']  <- tmp$rhoPrior$hi[brows,'sPhy'] <- NA
tmp$rhoPrior$lo[brows,'lPhy']  <- tmp$rhoPrior$hi[brows,'lPhy'] <- NA

brows <- grep('Pvol', rownames(tmp$rhoPrior$lo))
tmp$rhoPrior$lo[brows,'sZoo']  <- tmp$rhoPrior$hi[brows,'sZoo'] <- NA
tmp$rhoPrior$lo[brows,'lZoo']  <- tmp$rhoPrior$hi[brows,'lZoo'] <- NA

timeList <- mergeList(timeList, tmp)


effort <- list(columns = 1:S, values = edata)

modelList <- list( typeNames = 'DA', ng = 20000, burnin= 10000, 
           timeList=timeList, effort = effort)

output1 <- gjam(formulaRho, xdata=xdata, ydata=ydata, modelList=modelList, verbose = T)

save(output1, file = 'gjamOutputLakes1/gjamOutputLakes1.rdata')

plotPars <- list(specColor = specColor, PLOTALLY=T, SAVEPLOTS = T, outFolder = 'gjamOutputLakes1')
gjamPlot(output1,plotPars)

#doubling time in weeks:

log(2)/.4

```

```{r}

out <- output1$parameters
tnames <- c('rhoStandXTable', 'alphaTable')

for(k in 1:length(tnames)){
  
  xk <- out[tnames[k]][[1]]
  
  prior <- columnPaste(as.character(signif(xk[,'priorLo'], 3)), 
                       as.character(signif(xk[,'priorHi'], 3)), ', ')
  prior <- paste('(', prior, ')', sep='')
  prior <- .replaceString(prior, ',', ', ')
  xk <- xk[,!colnames(xk) %in% c('priorLo','priorHi')]
  
    post <- columnPaste(as.character(signif(xk[,'CI_025'], 4)), 
                       as.character(signif(xk[,'CI_975'], 4)), ', ')
  post <- paste('(', post, ')', sep='')
  post <- .replaceString(post, ',', ', ')
  xk <- xk[,!colnames(xk) %in% c('priorLo','priorHi','CI_025','CI_975')]
  
  print('')
  print(tnames[k])
  xp <- data.frame(xk, post, prior, stringsAsFactors = F)
  ww <- which(sapply(xp, is.complex))
  if(length(ww) > 0)for(w in ww)xp[[w]] <- as.character(xp[[w]])
  
  xp <- xtable( xp, digits = 4 )
  rownames(xp) <- NULL
  print( xp, hline.after=c(-1, 0), tabular.environment = "longtable",
         floating = F, include.rownames=FALSE)
}
```


Stability:

```{r, eval = F}
ngrid <- 11
wstar <- .wrapperEquilAbund(output1, nsim = 500, ngrid = ngrid, BYFACTOR = T, 
                            BYGROUP = F, verbose = verbose)

save(output1, wstar, file = 'gjamOutputLakes1/gjamOutputLakes1.rdata')


cols <- rev( colT(ngrid) )

notOther <- output1$inputs$notOther
ccMu <- wstar$ccMu[,notOther]
ccSd <- wstar$ccSd[,notOther]
ccx  <- wstar$x

ccx  <- ccx[, !colnames(ccx) %in% attributes(ccx)$factors, drop=F]
ccx  <- ccx[,-1, drop=F]

np <- ncol(ccMu)

npage <- 1
o   <- 1:np
if(np > 16){
  npage <- ceiling(np/16)
  np    <- 16
}

# 

alpha <- output1$parameters$alphaMu
rho   <- output1$parameters$rhoStandXmu

intercept <- 1
bt <- ccx[,'bass']*ccx[,'temp']
rx <- cbind(intercept, ccx, bt)     # assumes formula for rho
rx <- rx%*%rho
ax <- -t( t(rx)/diag(alpha) )



mfrow <- .getPlotLayout(np)

for(m in 1:ncol(ccx)){   # loop over predictors
  
  xm  <- colnames(ccx)[m]
  xx  <- ccx[,m]
#  atx <- quantile(xx,seq(0, 1, length=nbin))
  
#  xlimit <- c( sum( c(.7, .3)*atx[1:2] ), sum( c(.3, .7)*atx[(nbin-1):nbin] ) )
  
  k   <- 0
  add <- F
  o   <- 1:np
  o   <- o[o <= 16]
  
  
  for(p in 1:npage){
  
    npp <- ncol(ccMu) - k
    if(npp > np)npp <- np 
    mfrow <- .getPlotLayout(np)
    par(mfrow=mfrow, bty='n', oma = c(2,2,1,1), mar=c(3,3,2,1))
    pj <- 1
    
    for(j in o){
      
      yy  <- ccMu[,j]
      cc  <- ax[,j]
      
      xmids <- sort( unique( ccx[,1] ) )
      
      c95 <- tapply( yy, list(bin = ccx[,xm]), quantile, pnorm( c(-1.96, -1, 1, 1.96) ))
      ci <- matrix( unlist( c95 ), ncol = 4, byrow = T )
      rownames(ci) <- names(c95)
      
      cmid <- tapply( yy, list(bin = ccx[,xm]), quantile, .5 )
      
      for(s in 1:4)ci[,s] <- smooth(ci[,s])
      
      cmu <- tapply( yy, list(bin = ccx[,xm]), mean)
      amu <- tapply( cc, list(bin = ccx[,xm]), mean)
      
      nk <- length(xmids) 
      cdd  <- rev( colT(nk) )
      
      plot(xmids, cmid, xlim = range(xmids), ylim = range(ci), xlab = '',
           lwd = 2, col = 'grey', type = 'l')
      .shadeInterval(xmids, loHi = cbind(ci[,2],ci[,3]), add=T, trans = .2 )
      .shadeInterval(xmids, loHi = cbind(ci[,1],ci[,4]), add=T, trans = .2 )
      
       segments(xmids, ci[,2], xmids, ci[,3], col = cdd, lwd=6)
       arrows(xmids, ci[,1], xmids, ci[,4], col = cdd, lwd=1.5, angle=90, code=3,
             length=.03)
       points(xmids, cmid, col=cdd, cex=1.1, pch = 3, lwd = 5)
      
      points(xmids, cmu, pch = 15, col = cdd)
      
    #  lines(xmids,amu)
      
      
      k <- k + 1
      if(k > 26)k <- 1
      pj <- pj + 1
      
      lab <- colnames(ccMu)[j]
      
      .plotLabel( lab,above=T )
    }
    mtext( paste( xm, '(standard deviations)'), 1, outer=T)
    mtext('Equilibrium abundance', 2, outer=T)
    
    readline('equilibrium abundance -- return to continue ')
    
    o <- o + 16
    o <- o[o <= S]
    
  }
}


```







